===== /Users/mg/IdeaProjects/PingClient-Swing/src/test/java/Entity/ThreadEntityTest.java =====
package Entity;

import entity.ThreadFactory;
import entity.Thread;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

public class ThreadEntityTest
{
    private ThreadFactory threadFactory = new ThreadFactory();

    @Test
    void testToString()
    {
        Thread thread = threadFactory.create("benj", "Benj, Ali");
        assertEquals(thread.toString(), "Thread{" +
                "threadID=" + thread.getThreadID() +
                ", name='" + thread.getName() + '\'' +
                ", usernameList=" + thread.getUsernameList() +
                ", messageList=" + thread.getMessageList() +
                '}');

    }

    @Test
    void testSetName()
    {
        Thread thread = threadFactory.create("benj", "Benj, Ali");
        thread.setName("Ali");
        assertEquals(thread.getName(), "Ali");
    }

    @Test
    void testAltConstructor()
    {
        Thread thread = new Thread(1L, "Ben");
        assertEquals(thread.getThreadID(), 1L);
        assertEquals(thread.getName(), "Ben");
    }

    @Test
    void testConvertCommaSeperatedToListBranches()
    {
       Thread thread = threadFactory.create("Benj", null);
       Thread thread2 = threadFactory.create("Benj", "");
    }



}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/test/java/use_case/send_message/SendMessageInteractorTest.java =====
package use_case.send_message;

import static org.junit.jupiter.api.Assertions.*;

import java.io.IOException;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import entity.Message;
import entity.MessageFactory;

/**
 * Class for testing the Send Message Interactor.
 */
class SendMessageInteractorTest
{
    private MessageFactory messageFactory;
    private SendMessageInputData validInputData;
    private SendMessageInputData invalidInputDataEmptyContent;
    private SendMessageInputData invalidInputDataContentTooLong;

    @BeforeEach
    void setUp()
    {
        // Setup mock message factory
        messageFactory = new MessageFactory();

        // Setup valid input data
        validInputData = new SendMessageInputData(
                "How's it going chumps?", 1234L, "TestUser");

        // Setup invalid input data
        invalidInputDataEmptyContent = new SendMessageInputData(
                "", 1234L, "TestJoe");
        invalidInputDataContentTooLong = new SendMessageInputData(
                "C".repeat(Message.MESSAGE_MAX_LENGTH + 1), 1234L, "TestUser");
    }

    @Test
    void testExecuteValidInputSuccess()
    {
        // Create mock DAO for this specific test
        SendMessageMessageDataAccessInterface mockServer = new InMemoryMessageDataAccess();

        // Create mock presenter for this specific test
        SendMessageOutputBoundary sendMessagePresenter = new SendMessageOutputBoundary()
        {
            @Override
            public void prepareSuccessView(SendMessageOutputData outputData)
            {
                assertEquals("How's it going chumps?", outputData.getContent());
                assertEquals("TestUser", outputData.getSenderUsername());
                assertEquals("456786765644", outputData.getTimestamp());
                assertFalse(outputData.isUseCaseFailed());
            }

            @Override
            public void prepareFailView(String errorMessage)
            {
                fail("Failure is unexpected here.");
            }

            @Override
            public void switchToThreadsView()
            {
                fail("Switch is unexpected here.");
            }
        };

        // Create interactor for this specific test
        SendMessageInputBoundary interactor =
                new SendMessageInteractor(mockServer, messageFactory, sendMessagePresenter);

        // Assert
        interactor.execute(validInputData);
    }

    @Test
    void testExecuteServerServerError()
    {
        // Create mock DAO for this specific test
        SendMessageMessageDataAccessInterface mockServer = new InMemoryMessageDataAccessWithServerError();

        // Create mock presenter for this specific test
        SendMessageOutputBoundary sendMessagePresenter = new SendMessageOutputBoundary()
        {
            @Override
            public void prepareSuccessView(SendMessageOutputData outputData)
            {
                fail("Success is unexpected here.");
            }

            @Override
            public void prepareFailView(String errorMessage)
            {
                assertEquals("An unexpected error occurred: Server Error", errorMessage);
            }

            @Override
            public void switchToThreadsView()
            {
                fail("Switch is unexpected here.");
            }
        };

        // Create interactor for this specific test
        SendMessageInputBoundary interactor =
                new SendMessageInteractor(mockServer, messageFactory, sendMessagePresenter);

        // Assert
        interactor.execute(validInputData);
    }

    @Test
    void testExecuteServerClientError()
    {
        // Create mock DAO for this specific test
        SendMessageMessageDataAccessInterface mockServer = new InMemoryMessageDataAccessWithClientError();

        // Create mock presenter for this specific test
        SendMessageOutputBoundary sendMessagePresenter = new SendMessageOutputBoundary()
        {
            @Override
            public void prepareSuccessView(SendMessageOutputData outputData)
            {
                fail("Success is unexpected here.");
            }

            @Override
            public void prepareFailView(String errorMessage)
            {
                assertEquals("Some of your inputs are invalid.", errorMessage);
            }

            @Override
            public void switchToThreadsView()
            {
                fail("Switch is unexpected here.");
            }
        };

        // Create interactor for this specific test
        SendMessageInputBoundary interactor =
                new SendMessageInteractor(mockServer, messageFactory, sendMessagePresenter);

        // Assert
        interactor.execute(validInputData);
    }

    @Test
    void testExecuteEmptyContent()
    {
        // Create mock DAO for this specific test
        SendMessageMessageDataAccessInterface mockServer = new InMemoryMessageDataAccess();

        // Create mock presenter for this specific test
        SendMessageOutputBoundary sendMessagePresenter = new SendMessageOutputBoundary()
        {
            @Override
            public void prepareSuccessView(SendMessageOutputData outputData)
            {
                fail("Success is unexpected here.");
            }

            @Override
            public void prepareFailView(String errorMessage)
            {
                assertEquals("Message field is empty.", errorMessage);
            }

            @Override
            public void switchToThreadsView()
            {
                fail("Switch is unexpected here.");
            }
        };

        // Create interactor for this specific test
        SendMessageInputBoundary interactor =
                new SendMessageInteractor(mockServer, messageFactory, sendMessagePresenter);

        // Assert
        interactor.execute(invalidInputDataEmptyContent);
    }

    @Test
    void testExecuteContentTooLong()
    {
        // Create mock DAO for this specific test
        SendMessageMessageDataAccessInterface mockServer = new InMemoryMessageDataAccess();

        // Create mock presenter for this specific test
        SendMessageOutputBoundary sendMessagePresenter = new SendMessageOutputBoundary()
        {
            @Override
            public void prepareSuccessView(SendMessageOutputData outputData)
            {
                fail("Success is unexpected here.");
            }

            @Override
            public void prepareFailView(String errorMessage)
            {
                assertEquals("Message is too long. Must be under "
                        + Message.MESSAGE_MAX_LENGTH + " characters.", errorMessage);
            }

            @Override
            public void switchToThreadsView()
            {
                fail("Switch is unexpected here.");
            }
        };

        // Create interactor for this specific test
        SendMessageInputBoundary interactor =
                new SendMessageInteractor(mockServer, messageFactory, sendMessagePresenter);

        // Assert
        interactor.execute(invalidInputDataContentTooLong);
    }

    @Test
    void testSwitchToThreadsView()
    {
        // Create mock DAO for this specific test
        SendMessageMessageDataAccessInterface mockServer = new InMemoryMessageDataAccess();

        // Create mock presenter for this specific test
        SendMessageOutputBoundary sendMessagePresenter = new SendMessageOutputBoundary()
        {
            @Override
            public void prepareSuccessView(SendMessageOutputData outputData)
            {
                fail("Success is unexpected here.");
            }

            @Override
            public void prepareFailView(String errorMessage)
            {
                fail("Failure is unexpected here.");
            }

            @Override
            public void switchToThreadsView()
            {
                assertTrue(true);
            }
        };

        // Create interactor for this specific test
        SendMessageInputBoundary interactor =
                new SendMessageInteractor(mockServer, messageFactory, sendMessagePresenter);

        // Assert
        interactor.switchToThreadsView();
    }

    // == MOCK DAOs FOR TESTING ==

    /**
     * Mock class, mimics a functional server.
     */
    private static final class InMemoryMessageDataAccess implements SendMessageMessageDataAccessInterface
    {
        @Override
        public Message save(Message message, Long threadID)
        {
            return new Message(message.getContent(), message.getSenderUsername(), "456786765644");
        }
    }

    /**
     * Mock class, mimics a functional server that is given invalid inputs.
     */
    private static final class InMemoryMessageDataAccessWithClientError implements SendMessageMessageDataAccessInterface
    {
        @Override
        public Message save(Message message, Long threadID) throws IOException
        {
            throw new IOException("Some of your inputs are invalid.");
        }
    }

    /**
     * Mock class, mimics a dysfunctional server.
     */
    private static final class InMemoryMessageDataAccessWithServerError implements SendMessageMessageDataAccessInterface
    {
        @Override
        public Message save(Message message, Long threadID)
        {
            throw new RuntimeException("Server Error");
        }
    }
}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/test/java/use_case/logout/LogoutInteractorTest.java =====
package use_case.logout;

import data_access.PingBackend;
import data_access.UserDataAccessObject;
import entity.User;
import entity.UserFactory;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

public class LogoutInteractorTest
{
    @Test
    void successTest() throws Exception
    {
        PingBackend backend = new PingBackend("http://pingserver-env.eba-u7hgzajj.ca-central-1.elasticbeanstalk.com/");
        LogoutUserDataAccessInterface dataAccessObject = new UserDataAccessObject(backend);
        UserFactory userFactory = new UserFactory();
        User user = userFactory.create("benj", "password", "ben@gmail.com");
        User user2 = new User("benj");
        System.out.println(user.getUsername() + user.getPassword() + user.getEmail());
        backend.register(user.getUsername(), user.getEmail(), user.getPassword());
        backend.login("benj", "password");
        //verify that a token was given to the user initially
        //assertNotEquals(backend.getAccessToken(), null);
        System.out.println(backend.getAccessToken());
        // This creates a successPresenter that tests whether the test case is as we expect.
        LogoutOutputBoundary successPresenter = new LogoutOutputBoundary()
        {
            @Override
            public void prepareSuccessView()
            {
                // check that the token was deleted once the user logged out
                assertNull(backend.getAccessToken());
            }

            @Override
            public void prepareFailView(String error)
            {
                fail("Use case failure is unexpected.");
            }
        };

        LogoutInputBoundary interactor = new LogoutInteractor(dataAccessObject, successPresenter);
        interactor.execute();

    }
}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/test/java/use_case/add_thread/AddThreadInteractorTest.java =====
package use_case.add_thread;

import entity.Message;
import entity.Thread;
import entity.ThreadFactory;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Class for testing the Add Thread Interactor.
 */
class AddThreadInteractorTest
{
    private ThreadFactory threadFactory;

    private AddThreadInputData validInputData;
    private AddThreadInputData invalidInputDataEmptyName;
    private AddThreadInputData invalidInputDataNameTooLong;
    private AddThreadInputData invalidInputDataNameTooShort;
    private AddThreadInputData invalidInputDataEmptyUsers;
    private AddThreadInputData invalidInputDataPoorlyFormattedUsers;
    private AddThreadInputData invalidInputDataNullUserList;

    @BeforeEach
    void setUp()
    {
        // Setup mock thread factory
        threadFactory = new ThreadFactory();

        // Setup valid input data
        validInputData = new AddThreadInputData(
                "Valid Thread", "user1,user2,user3", "TestJoe");

        // Setup invalid input data
        invalidInputDataEmptyName = new AddThreadInputData(
                "", "user1,user2", "TestJoe");
        invalidInputDataNameTooLong = new AddThreadInputData(
                "A".repeat(Thread.THREAD_NAME_MAX_LENGTH + 1),
                "user1,user2", "TestJoe");
        invalidInputDataNameTooShort = new AddThreadInputData(
                "A", "user1,user2", "TestJoe");
        invalidInputDataEmptyUsers = new AddThreadInputData(
                "Valid Thread", "", "TestJoe");
        invalidInputDataPoorlyFormattedUsers = new AddThreadInputData(
                "Valid Thread", "user1,,user2", "TestJoe");
        invalidInputDataNullUserList = new AddThreadInputData("InvalidThread",null, "Ben");
    }

    @Test
    void testExecuteValidInputSuccess()
    {
        // create mock DAO for this specific test
        AddThreadThreadDataAccessInterface mockServer = new InMemoryThreadDataAccess();

        // create mock presenter for this specific test
        AddThreadOutputBoundary addThreadPresenter = new AddThreadOutputBoundary()
        {
            @Override
            public void prepareSuccessView(AddThreadOutputData outputData, String successMessage)
            {
                assertEquals("Valid Thread", outputData.getThreadName());
                assertEquals(3456L, outputData.getThreadID());
                assertEquals("New thread 'Valid Thread' has been successfully created.", successMessage);
            }

            @Override
            public void prepareFailView(String errorMessage)
            {
                fail("Failure is unexpected here");
            }

            @Override
            public void switchToThreadsView()
            {
                fail("Switch is unexpected here");
            }
        };

        // create mock interactor for this specific test
        AddThreadInputBoundary interactor = new AddThreadInteractor(mockServer, addThreadPresenter, threadFactory);

        // Assert
        interactor.execute(validInputData);
    }

    @Test
    void testExecuteEmptyThreadName()
    {
        // create mock DAO for this specific test
        AddThreadThreadDataAccessInterface mockServer = new InMemoryThreadDataAccess();

        // create mock presenter for this specific test
        AddThreadOutputBoundary addThreadPresenter = new AddThreadOutputBoundary()
        {
            @Override
            public void prepareSuccessView(AddThreadOutputData outputData, String successMessage)
            {
                fail("Success is unexpected here");
            }

            @Override
            public void prepareFailView(String errorMessage)
            {
                assertEquals("Thread name field is empty.", errorMessage);
            }

            @Override
            public void switchToThreadsView()
            {
                fail("Switch is unexpected here");
            }
        };

        // create mock interactor for this specific test
        AddThreadInputBoundary interactor = new AddThreadInteractor(mockServer, addThreadPresenter, threadFactory);

        // Assert
        interactor.execute(invalidInputDataEmptyName);
    }

    @Test
    void testExecuteThreadNameTooLong()
    {
        // create mock DAO for this specific test
        AddThreadThreadDataAccessInterface mockServer = new InMemoryThreadDataAccess();

        // create mock presenter for this specific test
        AddThreadOutputBoundary addThreadPresenter = new AddThreadOutputBoundary()
        {
            @Override
            public void prepareSuccessView(AddThreadOutputData outputData, String successMessage)
            {
                fail("Success is unexpected here");
            }

            @Override
            public void prepareFailView(String errorMessage)
            {
                assertEquals("Thread name is too long. Must be under "
                        + Thread.THREAD_NAME_MAX_LENGTH + " characters.", errorMessage);
            }

            @Override
            public void switchToThreadsView()
            {
                fail("Switch is unexpected here");
            }
        };

        // create mock interactor for this specific test
        AddThreadInputBoundary interactor = new AddThreadInteractor(mockServer, addThreadPresenter, threadFactory);

        // Assert
        interactor.execute(invalidInputDataNameTooLong);
    }

    @Test
    void testExecuteThreadNameTooShort()
    {
        // create mock DAO for this specific test
        AddThreadThreadDataAccessInterface mockServer = new InMemoryThreadDataAccess();

        // create mock presenter for this specific test
        AddThreadOutputBoundary addThreadPresenter = new AddThreadOutputBoundary()
        {
            @Override
            public void prepareSuccessView(AddThreadOutputData outputData, String successMessage)
            {
                fail("Success is unexpected here");
            }

            @Override
            public void prepareFailView(String errorMessage)
            {
                assertEquals("Thread name is too short. Must be at least "
                        + Thread.THREAD_NAME_MIN_LENGTH + " characters.", errorMessage);
            }

            @Override
            public void switchToThreadsView()
            {
                fail("Switch is unexpected here");
            }
        };

        // create mock interactor for this specific test
        AddThreadInputBoundary interactor = new AddThreadInteractor(mockServer, addThreadPresenter, threadFactory);

        // Assert
        interactor.execute(invalidInputDataNameTooShort);
    }

    @Test
    void testExecuteEmptyUserList()
    {
        // create mock DAO for this specific test
        AddThreadThreadDataAccessInterface mockServer = new InMemoryThreadDataAccess();

        // create mock presenter for this specific test
        AddThreadOutputBoundary addThreadPresenter = new AddThreadOutputBoundary()
        {
            @Override
            public void prepareSuccessView(AddThreadOutputData outputData, String successMessage)
            {
                fail("Success is unexpected here");
            }

            @Override
            public void prepareFailView(String errorMessage)
            {
                assertEquals("List of Users is Empty", errorMessage);
            }

            @Override
            public void switchToThreadsView()
            {
                fail("Switch is unexpected here");
            }
        };

        // create mock interactor for this specific test
        AddThreadInputBoundary interactor = new AddThreadInteractor(mockServer, addThreadPresenter, threadFactory);

        // Assert
        interactor.execute(invalidInputDataEmptyUsers);
    }

    @Test
    void testExecutePoorlyFormattedUserList()
    {
        // create mock DAO for this specific test
        AddThreadThreadDataAccessInterface mockServer = new InMemoryThreadDataAccess();

        // create mock presenter for this specific test
        AddThreadOutputBoundary addThreadPresenter = new AddThreadOutputBoundary()
        {
            @Override
            public void prepareSuccessView(AddThreadOutputData outputData, String successMessage)
            {
                fail("Success is unexpected here");
            }

            @Override
            public void prepareFailView(String errorMessage)
            {
                assertEquals("List of users is poorly formatted. \n "
                        + "(should be separated by commas and contain no spaces)", errorMessage);
            }

            @Override
            public void switchToThreadsView()
            {
                fail("Switch is unexpected here");
            }
        };

        // create mock interactor for this specific test
        AddThreadInputBoundary interactor = new AddThreadInteractor(mockServer, addThreadPresenter, threadFactory);

        // Assert
        interactor.execute(invalidInputDataPoorlyFormattedUsers);
    }

    @Test
    void testExecuteServerError()
    {
        // create mock DAO for this specific test
        AddThreadThreadDataAccessInterface mockServer = new InMemoryThreadDataAccessWithError();

        // create mock presenter for this specific test
        AddThreadOutputBoundary addThreadPresenter = new AddThreadOutputBoundary()
        {
            @Override
            public void prepareSuccessView(AddThreadOutputData outputData, String successMessage)
            {
                fail("Success is unexpected here");
            }

            @Override
            public void prepareFailView(String errorMessage)
            {
                assertEquals("Server Error", errorMessage);
            }

            @Override
            public void switchToThreadsView()
            {
                fail("Switch is unexpected here");
            }
        };

        // create mock interactor for this specific test
        AddThreadInputBoundary interactor = new AddThreadInteractor(mockServer, addThreadPresenter, threadFactory);

        // Assert
        interactor.execute(validInputData);
    }

    @Test
    void testSwitchToThreadsView()
    {
        // create mock DAO for this specific test
        AddThreadThreadDataAccessInterface mockServer = new InMemoryThreadDataAccessWithError();

        // setup the mock presenter
        AddThreadOutputBoundary addThreadPresenter = new AddThreadOutputBoundary()
        {
            @Override
            public void prepareSuccessView(AddThreadOutputData outputData, String successMessage)
            {
                fail("Success is unexpected here");
            }

            @Override
            public void prepareFailView(String error)
            {
                fail("Fail is unexpected here");
            }

            @Override
            public void switchToThreadsView()
            {
                assertTrue(true);

            }
        };

        // create mock interactor for this specific test
        AddThreadInputBoundary interactor = new AddThreadInteractor(mockServer, addThreadPresenter, threadFactory);

        // Assert
        interactor.switchToThreadsView();

    }

    @Test
    void testGetCurrentUsername()
    {
       String currentUsername = validInputData.getCurrentUsername();
       assertEquals("TestJoe", currentUsername);
    }

    @Test
    void testInteractorCatches()
    {
        // create mock DAO for this specific test
        AddThreadThreadDataAccessInterface mockServer = new InMemoryThreadDataAccessWithIllegalError();

        // create mock presenter for this specific test
        AddThreadOutputBoundary addThreadPresenter = new AddThreadOutputBoundary()
        {
            @Override
            public void prepareSuccessView(AddThreadOutputData outputData, String successMessage)
            {
                fail("Success is unexpected here");
            }

            @Override
            public void prepareFailView(String errorMessage)
            {
                assertEquals("Access Error", errorMessage);
            }

            @Override
            public void switchToThreadsView()
            {
                fail("Switch is unexpected here");
            }
        };

        // create mock interactor for this specific test
        AddThreadInputBoundary interactor = new AddThreadInteractor(mockServer, addThreadPresenter, threadFactory);

        // Assert
        interactor.execute(validInputData);
    }



    // == MOCK DAOs FOR TESTING ==

    /**
     * Mock class, mocks the behaviour of a functional server.
     */
    private static final class InMemoryThreadDataAccess implements AddThreadThreadDataAccessInterface
    {
        @Override
        public Thread save(Thread thread)
        {
            List<String> updatedUserlist = new ArrayList<>(thread.getUsernameList());
            updatedUserlist.add("TestJoe");
            List<Message> emptyMessageList = new ArrayList<>();

            return new Thread(thread.getName(), updatedUserlist, emptyMessageList, 3456L);
        }
    }

    /**
     * Mock class, mocks the behaviour of a dysfunctional server.
     */
    private static final class InMemoryThreadDataAccessWithError implements AddThreadThreadDataAccessInterface
    {
        @Override
        public Thread save(Thread thread)
        {
            // TODO: based on what the server ends up outputting as an error, change this
            throw new RuntimeException("Server Error");
        }
    }
    private static final class InMemoryThreadDataAccessWithIllegalError implements AddThreadThreadDataAccessInterface
    {
        @Override
        public Thread save(Thread thread) throws IllegalAccessException {
            // TODO: based on what the server ends up outputting as an error, change this
            throw new IllegalAccessException("Access Error");
        }
    }
}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/test/java/use_case/login/LoginInteractorTest.java =====
package use_case.login;

import entity.User;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.json.JSONObject;

import java.util.HashMap;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Unit tests for LoginInteractor with In-Memory Database.
 */
class LoginInteractorTest {

    private InMemoryUserDataAccess inMemoryDataAccess;
    private StubLoginPresenter stubLoginPresenter;
    private LoginInteractor interactor;

    @BeforeEach
    void setUp() {
        inMemoryDataAccess = new InMemoryUserDataAccess();
        stubLoginPresenter = new StubLoginPresenter();
        interactor = new LoginInteractor(inMemoryDataAccess, stubLoginPresenter);
    }

    @Test
    void testSuccessfulLoginAfterSavingUser() {
        inMemoryDataAccess.saveUser("testUser", "securePassword", "email@example.com");

        LoginInputData inputData = new LoginInputData("testUser", "securePassword");
        interactor.execute(inputData);

        assertNotNull(stubLoginPresenter.successData);
        assertEquals("testUser", stubLoginPresenter.successData.getUsername());
        assertEquals("Login successful", stubLoginPresenter.successData.getMessage());
        assertNull(stubLoginPresenter.errorMessage);
    }

    @Test
    void testLoginFailsWithIncorrectPassword() {
        inMemoryDataAccess.saveUser("testUser", "securePassword", "email@example.com");

        LoginInputData inputData = new LoginInputData("testUser", "wrongPassword");
        interactor.execute(inputData);

        assertNull(stubLoginPresenter.successData);
        assertEquals("Invalid credentials", stubLoginPresenter.errorMessage);
    }

    @Test
    void testLoginFailsForNonexistentUser() {
        LoginInputData inputData = new LoginInputData("nonexistentUser", "password123");
        interactor.execute(inputData);

        assertNull(stubLoginPresenter.successData);
        assertEquals("Invalid credentials", stubLoginPresenter.errorMessage);
    }

    @Test
    void testLoginThrowsException() {
        inMemoryDataAccess.setThrowException(true);

        LoginInputData inputData = new LoginInputData("testUser", "securePassword");
        interactor.execute(inputData);

        assertNull(stubLoginPresenter.successData);
        assertTrue(stubLoginPresenter.errorMessage.startsWith("An error occurred during login:"));
    }

    @Test
    void testElseBranch() {
        inMemoryDataAccess.setCustomResponse(new JSONObject()
                .put("randomKey", "someValue") // random key unrelated to authToken or error
        );

        LoginInputData inputData = new LoginInputData("user@example.com", "password123");
        interactor.execute(inputData);

        // Assert: ensure the else block is executed
        assertNull(stubLoginPresenter.successData); // No success data
        assertEquals("Login failed", stubLoginPresenter.errorMessage); // default failure message
    }

    @Test
    void testSwitchToSignUpView() {
        interactor.switchToSignUpView();

        assertTrue(stubLoginPresenter.switchToSignUpCalled);
    }

    // In-Memory Database Implementation
    static class InMemoryUserDataAccess implements LoginUserDataAccessInterface {
        private final Map<String, User> database = new HashMap<>();
        private String currentUsername = null;
        private boolean throwException = false;
        private JSONObject customResponse = null;

        void saveUser(String username, String password, String email) {
            database.put(username, new User(username, password, email));
        }

        void setThrowException(boolean value) {
            throwException = value;
        }

        void setCustomResponse(JSONObject response) { // only used for testing else branch
            this.customResponse = response;
        }

        @Override
        public boolean existsByName(String username) {
            return database.containsKey(username);
        }

        @Override
        public JSONObject validateCredentials(String username, String password) {
            if (throwException) {
                throw new RuntimeException("Simulated database exception");
            }
            if (customResponse != null) {
                return customResponse; // return the custom response if set
            }

            User user = database.get(username);
            if (user != null && user.getPassword().equals(password)
            && user.getUsername().equals(username)) {
                return new JSONObject()
                        .put("authToken", "validToken")
                        .put("username", username)
                        .put("message", "Login successful");
            } else {
                return new JSONObject()
                        .put("error", true)
                        .put("message", "Invalid credentials");
            }
        }

        @Override
        public void save(User user) {
            database.put(user.getUsername(), user);
        }

        @Override
        public User get(String username) {
            return database.get(username);
        }

        @Override
        public String getCurrentUsername() {
            return currentUsername;
        }

        @Override
        public void setCurrentUsername(String username) {
            this.currentUsername = username;
        }
    }


    // Stub Presenter Implementation
    static class StubLoginPresenter implements LoginOutputBoundary {
        LoginOutputData successData = null;
        String errorMessage = null;
        boolean switchToSignUpCalled = false;

        @Override
        public void prepareSuccessView(LoginOutputData outputData) {
            this.successData = outputData;
        }

        @Override
        public void prepareFailView(String errorMessage) {
            this.errorMessage = errorMessage;
        }

        @Override
        public void switchToSignUpView() {
            this.switchToSignUpCalled = true;
        }
    }
}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/infustructure/AbstractAPICall.java =====
package infustructure;

import org.json.JSONObject;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.net.HttpURLConnection;
import java.net.URL;

public class AbstractAPICall
{
    private final String serverURL;
    // parameters for api calls
    private String accessToken;


    public AbstractAPICall()
    {
        this.serverURL = null;
        this.accessToken = "http://pingserver-env.eba-u7hgzajj.ca-central-1.elasticbeanstalk.com/";
    }

    /**
     * Method to send api calls to the server
     *
     * @param endpoint
     * @param method
     * @param body
     * @return
     * @throws Exception
     */
    public String sendRequest(
            String endpoint,
            String method,
            JSONObject body,
            Boolean isAuthenticated
    ) throws Exception
    {
        // fix the new URL
        URL url = new URL(serverURL + endpoint);

        // make a URL connection
        HttpURLConnection conn = (HttpURLConnection) url.openConnection();
        conn.setRequestMethod(method);
        conn.setRequestProperty("Content-Type", "application/json");

        if (isAuthenticated && accessToken != null)
        {
            conn.setRequestProperty("Authorization", "Bearer " + accessToken);
        }

        // Set up body
        if (body != null)
        {
            conn.setDoOutput(true);
            try (OutputStream os = conn.getOutputStream())
            {
                os.write(body.toString().getBytes());
                os.flush();
            }
        }

        int responseCode = conn.getResponseCode();

        BufferedReader reader = new BufferedReader(
                new InputStreamReader(responseCode >= 200 && responseCode < 300
                        ? conn.getInputStream()
                        : conn.getErrorStream())
        );

        StringBuilder response = new StringBuilder();
        String line;
        while ((line = reader.readLine()) != null)
        {
            response.append(line);
        }
        reader.close();

        return response.toString();
    }

}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/interface_adapter/ViewManagerModel.java =====
package interface_adapter;

/**
 * Model for the View Manager. Its state is the name of the View which
 * is currently active. An initial state of "" is used.
 */
// TODO: overwrite with our code
public class ViewManagerModel extends ViewModel<String>
{

    public ViewManagerModel()
    {
        super("view manager");
        this.setState("");
    }

}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/interface_adapter/signup/SignupState.java =====
package interface_adapter.signup;

/**
 * The state for the Signup View Model.
 */
// TODO: overwrite with our code
public final class SignupState
{
    private String username = "";
    private String usernameError;
    private String email;
    private String emailError;
    private String password = "";
    private String passwordError;
    private String repeatPassword = "";
    private String repeatPasswordError;

    public String getUsername()
    {
        return username;
    }

    public void setUsername(String username)
    {
        this.username = username;
    }

    public String getUsernameError()
    {
        return usernameError;
    }

    public void setUsernameError(String usernameError)
    {
        this.usernameError = usernameError;
    }

    public String getPassword()
    {
        return password;
    }

    public void setPassword(String password)
    {
        this.password = password;
    }

    public String getPasswordError()
    {
        return passwordError;
    }

    public void setPasswordError(String passwordError)
    {
        this.passwordError = passwordError;
    }

    public String getRepeatPassword()
    {
        return repeatPassword;
    }

    public void setRepeatPassword(String repeatPassword)
    {
        this.repeatPassword = repeatPassword;
    }

    public String getRepeatPasswordError()
    {
        return repeatPasswordError;
    }

    public void setRepeatPasswordError(String repeatPasswordError)
    {
        this.repeatPasswordError = repeatPasswordError;
    }

    public String getEmail()
    {
        return email;
    }

    public void setEmail(String email)
    {
        this.email = email;
    }

    public String getEmailError()
    {
        return emailError;
    }

    public void setEmailError(String emailError)
    {
        this.emailError = emailError;
    }

    @Override
    public String toString()
    {
        return "SignupState{"
                + "username='" + username + '\''
                + ", password='" + password + '\''
                + ", repeatPassword='" + repeatPassword + '\''
                + '}';
    }
}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/interface_adapter/signup/SignupViewModel.java =====
package interface_adapter.signup;

import interface_adapter.ViewModel;

/**
 * The ViewModel for the Signup View.
 */
// TODO: overwrite with our code
public class SignupViewModel extends ViewModel<SignupState>
{

    public static final String TITLE_LABEL = "Sign Up View";
    public static final String USERNAME_LABEL = "Choose username";
    public static final String EMAIL_LABEL = "Choose email";
    public static final String PASSWORD_LABEL = "Choose password";
    public static final String REPEAT_PASSWORD_LABEL = "Enter password again";

    public static final String SIGNUP_BUTTON_LABEL = "Sign up";
    public static final String CANCEL_BUTTON_LABEL = "Cancel";

    public static final String TO_LOGIN_BUTTON_LABEL = "Go to Login";

    public SignupViewModel()
    {
        super("sign up");
        setState(new SignupState());
    }

}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/interface_adapter/signup/SignupPresenter.java =====
package interface_adapter.signup;

import interface_adapter.ViewManagerModel;
import interface_adapter.login.LoginState;
import interface_adapter.login.LoginViewModel;
import use_case.signup.SignupOutputBoundary;
import use_case.signup.SignupOutputData;

/**
 * The Presenter for the Signup Use Case.
 */
// TODO: overwrite with our code
public class SignupPresenter implements SignupOutputBoundary
{

    private final SignupViewModel signupViewModel;
    private final LoginViewModel loginViewModel;
    private final ViewManagerModel viewManagerModel;

    public SignupPresenter(ViewManagerModel viewManagerModel,
                           SignupViewModel signupViewModel,
                           LoginViewModel loginViewModel)
    {
        this.viewManagerModel = viewManagerModel;
        this.signupViewModel = signupViewModel;
        this.loginViewModel = loginViewModel;
    }

    @Override
    public void prepareSuccessView(SignupOutputData response)
    {
        // On success, switch to the login view.
        final LoginState loginState = loginViewModel.getState();
        loginState.setUsernameOrEmail(response.getUsername());
        this.loginViewModel.setState(loginState);
        loginViewModel.firePropertyChanged();

        viewManagerModel.setState(loginViewModel.getViewName());
        viewManagerModel.firePropertyChanged();
    }

    @Override
    public void prepareFailView(String error)
    {
        System.out.println(error);
        final SignupState signupState = signupViewModel.getState();
        signupState.setUsernameError(error);
        signupViewModel.firePropertyChanged();
    }

    @Override
    public void switchToLoginView()
    {
        viewManagerModel.setState(loginViewModel.getViewName());
        viewManagerModel.firePropertyChanged();
    }
}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/interface_adapter/signup/SignupController.java =====
package interface_adapter.signup;

import use_case.signup.SignupInputBoundary;
import use_case.signup.SignupInputData;

/**
 * Controller for the Signup Use Case.
 */
// TODO: overwrite with our code
public class SignupController
{

    private final SignupInputBoundary userSignupUseCaseInteractor;

    public SignupController(SignupInputBoundary userSignupUseCaseInteractor)
    {
        this.userSignupUseCaseInteractor = userSignupUseCaseInteractor;
    }

    /**
     * Executes the Signup Use Case.
     *
     * @param username  the username to sign up
     * @param email     the email of the user
     * @param password1 the password
     * @param password2 the password repeated
     */
    public void execute(String username, String email, String password1, String password2)
    {
//        System.out.println(username + " " + email + " " + password1 + " " + password2);
        final SignupInputData signupInputData = new SignupInputData(
                username,
                password1,
                password2,
                email
        );

        userSignupUseCaseInteractor.execute(signupInputData);
    }

    /**
     * Executes the "switch to LoginView" Use Case.
     */
    public void switchToLoginView()
    {
        userSignupUseCaseInteractor.switchToLoginView();
    }
}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/interface_adapter/send_message/ChatState.java =====
package interface_adapter.send_message;

import java.util.ArrayList;
import java.util.List;

/**
 * Represents the current state of the Chat View Model.
 * PRECONDITION: all sub-arrays of allMessages are of length 3, the first String being the sender's username,
 * the second being the message content and the third being the timestamp.
 */
public class ChatState
{
    private String messageInput = "";
    private String sendMessageError;
    private String currentUsername;
    private String currentThreadName = "";
    private Long currentThreadID;
    private List<String[]> allMessages = new ArrayList<>();

    public final String getMessageInput()
    {
        return messageInput;
    }

    public final void setMessageInput(String messageInput)
    {
        this.messageInput = messageInput;
    }

    public final String getSendMessageError()
    {
        return sendMessageError;
    }

    public final void setSendMessageError(String sendMessageError)
    {
        this.sendMessageError = sendMessageError;
    }

    public final String getCurrentThreadName()
    {
        return currentThreadName;
    }

    public final void setCurrentThreadName(String currentThreadName)
    {
        this.currentThreadName = currentThreadName;
    }

    public final Long getCurrentThreadID()
    {
        return currentThreadID;
    }

    public final void setCurrentThreadID(Long currentThreadID)
    {
        this.currentThreadID = currentThreadID;
    }

    public final void setAllMessages(List<String[]> allMessages)
    {
        this.allMessages = allMessages;
    }

    public final List<String[]> getAllMessages()
    {
        return allMessages;
    }

    public final String getCurrentUsername()
    {
        return currentUsername;
    }

    public final void setCurrentUsername(String currentUsername)
    {
        this.currentUsername = currentUsername;
    }

    @Override
    public String toString()
    {
        return "ChatState{"
                + "messageInput='" + messageInput + '\''
                + ", allMessages='" + allMessages.toString() + '\''
                + "currentThreadID='" + currentThreadID + '\''
                + "currentThreadName='" + currentThreadName + '\''
                + "currentUsername='" + currentUsername + '\''
                + '}';
    }

    /**
     * Adds a message to allMessages.
     *
     * @param username       the sender of the message (always the current user)
     * @param messageContent the message content
     * @param timestamp      the timestamp of the message
     */
    public void addMessage(String username, String messageContent, String timestamp)
    {
        String[] newMessageTuple = new String[3];
        newMessageTuple[0] = username;
        newMessageTuple[1] = messageContent;
        newMessageTuple[2] = timestamp;

        this.allMessages.add(newMessageTuple);
    }

    /**
     * Resets the chat state, to be used on logout.
     */
    public void resetChatState()
    {
        this.messageInput = "";
        this.sendMessageError = null;
        this.currentThreadName = "";
        this.currentThreadID = null;
        this.allMessages = new ArrayList<>();
    }
}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/interface_adapter/send_message/SendMessagePresenter.java =====
package interface_adapter.send_message;

import java.util.ArrayList;

import interface_adapter.ViewManagerModel;
import interface_adapter.threads.ThreadsViewModel;
import use_case.send_message.SendMessageOutputBoundary;
import use_case.send_message.SendMessageOutputData;

/**
 * The Presenter for the Send Message Use Case.
 */
public final class SendMessagePresenter implements SendMessageOutputBoundary
{
    private final ChatViewModel chatViewModel;
    private final ThreadsViewModel threadsViewModel;
    private final ViewManagerModel viewManagerModel;

    public SendMessagePresenter(ViewManagerModel viewManagerModel,
                                ChatViewModel chatViewModel,
                                ThreadsViewModel threadsViewModel)
    {
        this.chatViewModel = chatViewModel;
        this.threadsViewModel = threadsViewModel;
        this.viewManagerModel = viewManagerModel;
    }

    @Override
    public void prepareSuccessView(SendMessageOutputData outputData)
    {
        // Update the chatViewModel with the new message.
        final ChatState chatState = chatViewModel.getState();
        chatState.setMessageInput("");
        chatState.addMessage(outputData.getSenderUsername(), outputData.getContent(), outputData.getTimestamp());
        chatState.setSendMessageError(null);
        chatViewModel.firePropertyChanged("message_update");
    }

    @Override
    public void prepareFailView(String errorMessage)
    {
        final ChatState chatState = chatViewModel.getState();
        chatState.setSendMessageError(errorMessage);
        chatState.setMessageInput("");
        chatViewModel.firePropertyChanged();
    }

    @Override
    public void switchToThreadsView()
    {
        // set chat state to default (same current user, however)
        final ChatState chatState = chatViewModel.getState();
        chatState.setSendMessageError(null);
        chatState.setCurrentThreadID(null);
        chatState.setAllMessages(new ArrayList<>());
        chatViewModel.firePropertyChanged("full_message_update");

        // switch the active state in the view manager
        viewManagerModel.setState(threadsViewModel.getViewName());
        viewManagerModel.firePropertyChanged();
    }
}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/interface_adapter/send_message/ChatViewModel.java =====
package interface_adapter.send_message;

import java.awt.*;

import interface_adapter.ViewModel;

/**
 * The View Model for the Chat View.
 */
public class ChatViewModel extends ViewModel<ChatState>
{
    public static final String SEND_BUTTON_LABEL = "Send";
    public static final String RETURN_BUTTON_LABEL = "Return To Threads";
    public static final String REFRESH_BUTTON_LABEL = "Refresh";

    public static final int BORDER_DIMENSIONS = 40;
    public static final Font MESSAGE_FONT = new Font("Arial", Font.PLAIN, 13);
    public static final int FONT_SIZE_MESSAGE_SENDER_USERNAME_LABEL = 10;
    public static final int FONT_SIZE_MESSAGE_CONTENT_LABEL = 13;
    public static final int FONT_SIZE_MESSAGE_TIMESTAMP_LABEL = 10;
    public static final int[] LIGHT_BLUE_RGB = {173, 216, 230};
    public static final int[] LIGHT_GREY_RGB = {211, 211, 211};
    public static final int MESSAGE_SPACING = 2;

    public ChatViewModel()
    {
        super("chat");
        setState(new ChatState());
    }
}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/interface_adapter/send_message/SendMessageController.java =====
package interface_adapter.send_message;

import use_case.send_message.SendMessageInputBoundary;
import use_case.send_message.SendMessageInputData;

/**
 * Controller for the Send Message Use Case.
 */
public class SendMessageController
{
    private final SendMessageInputBoundary sendMessageUseCaseInteractor;

    public SendMessageController(SendMessageInputBoundary userSendMessageUseCaseInteractor)
    {
        this.sendMessageUseCaseInteractor = userSendMessageUseCaseInteractor;
    }

    /**
     * Executes the "Send Message" Use Case.
     *
     * @param threadID       the threadID of the thread the message is being sent within
     * @param content        the content of the message
     * @param senderUsername the username of the current user of the program
     */
    public void execute(String content, Long threadID, String senderUsername)
    {
        final SendMessageInputData sendMessageInputData = new SendMessageInputData(content, threadID, senderUsername);
        sendMessageUseCaseInteractor.execute(sendMessageInputData);
    }

    /**
     * Executes the "switch to Threads View" Use Case.
     */
    public void switchToThreadsView()
    {
        this.sendMessageUseCaseInteractor.switchToThreadsView();
    }
}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/interface_adapter/logout/LogoutPresenter.java =====
package interface_adapter.logout;

import interface_adapter.ViewManagerModel;
import interface_adapter.login.LoginState;
import interface_adapter.login.LoginViewModel;
import interface_adapter.send_message.ChatState;
import interface_adapter.send_message.ChatViewModel;
import interface_adapter.threads.ThreadsState;
import interface_adapter.threads.ThreadsViewModel;
import use_case.logout.LogoutOutputBoundary;

/**
 * The Presenter for the Logout Use Case.
 */
public class LogoutPresenter implements LogoutOutputBoundary
{

    private final ViewManagerModel viewManagerModel;
    private final LoginViewModel loginViewModel;
    private final ThreadsViewModel threadsViewModel;
    private final ChatViewModel chatViewModel;

    public LogoutPresenter(ViewManagerModel viewManagerModel,
                           LoginViewModel loginViewModel,
                           ThreadsViewModel threadsViewModel, ChatViewModel chatViewModel)
    {
        this.viewManagerModel = viewManagerModel;
        this.loginViewModel = loginViewModel;
        this.threadsViewModel = threadsViewModel;
        this.chatViewModel = chatViewModel;
    }

    @Override
    public void prepareSuccessView()
    {
        // 1. get the LoggedInState out of the appropriate View Model,
        final ThreadsState threadsState = threadsViewModel.getState();
        // 2. set the username in the state to the empty string
        threadsState.resetThreadData();
        // 3. set the state in the LoggedInViewModel to the updated state
        threadsViewModel.setState(threadsState);
        // 4. firePropertyChanged so that the View that is listening is updated.
        threadsViewModel.firePropertyChanged("logged-out");

        // delete the information in the chat state
        final ChatState chatState = chatViewModel.getState();
        chatState.resetChatState();
        chatViewModel.setState(chatState);
        chatViewModel.firePropertyChanged();

        // 5. get the LoginState out of the appropriate View Model,
        final LoginState loginState = loginViewModel.getState();
        // 6. set the username and password in the state to the empty string
        loginState.setUsernameOrEmail("");
        loginState.setPassword("");
        // 7. set the state in the LoginViewModel to the updated state
        loginViewModel.setState(loginState);
        // 8. firePropertyChanged so that the View that is listening is updated.
        loginViewModel.firePropertyChanged();

        // This code tells the View Manager to switch to the LoginView.
        viewManagerModel.setState(loginViewModel.getViewName());
        viewManagerModel.firePropertyChanged();
    }

    @Override
    public void prepareFailView(String error)
    {
        // No need to add code here. We'll assume that logout can't fail.
    }
}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/interface_adapter/logout/LogoutController.java =====
package interface_adapter.logout;

import use_case.logout.LogoutInputBoundary;

/**
 * The controller for the Logout Use Case.
 */
public class LogoutController
{

    private final LogoutInputBoundary logoutInteractor;

    public LogoutController(LogoutInputBoundary logoutUseCaseInteractor)
    {
        this.logoutInteractor = logoutUseCaseInteractor;
    }

    /**
     * Executes the Logout Use Case.
     */
    public void execute()
    {
        logoutInteractor.execute();

    }
}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/interface_adapter/add_thread/AddThreadViewModel.java =====
package interface_adapter.add_thread;

import interface_adapter.ViewModel;

/**
 * The ViewModel for the Add Thread View.
 */
public class AddThreadViewModel extends ViewModel<AddThreadState>
{

    public static final String TITLE_LABEL = "Create New Thread View";
    public static final String THREAD_NAME_LABEL = "Enter new thread name";
    public static final String USERS_LIST_LABEL = "Enter list of users of this thread";
    public static final String TO_THREADS_BUTTON_LABEL = "Back to all threads";
    public static final String ADD_THREAD_BUTTON_LABEL = "Create thread";

    public static final int BORDER_DIMENSIONS = 40;

    public AddThreadViewModel()
    {
        super("add thread");
        setState(new AddThreadState());
    }
}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/interface_adapter/add_thread/AddThreadState.java =====
package interface_adapter.add_thread;

/**
 * The current state of the Add Thread View Model.
 */
public final class AddThreadState
{
    private String currentUsername = "";
    private String threadName = "";
    private String usernameList = "";
    private String addThreadError;
    private String addThreadSuccess;

    public String getCurrentUsername()
    {
        return currentUsername;
    }

    public void setCurrentUsername(String currentUsername)
    {
        this.currentUsername = currentUsername;
    }

    public String getThreadName()
    {
        return threadName;
    }

    public void setThreadName(String threadName)
    {
        this.threadName = threadName;
    }

    public String getAddThreadError()
    {
        return addThreadError;
    }

    public void setAddThreadError(String addThreadError)
    {
        this.addThreadError = addThreadError;
    }

    public String getUsernameList()
    {
        return usernameList;
    }

    public void setUsernameList(String usernameList)
    {
        this.usernameList = usernameList;
    }

    public String getAddThreadSuccess()
    {
        return addThreadSuccess;
    }

    public void setAddThreadSuccess(String addThreadSuccess)
    {
        this.addThreadSuccess = addThreadSuccess;
    }

    @Override
    public String toString()
    {
        return "AddThreadState{"
                + "thread_name='" + threadName + '\''
                + ", users_list='" + usernameList + '\''
                + ", error='" + addThreadError + '\''
                + '}';
    }
}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/interface_adapter/add_thread/AddThreadPresenter.java =====
package interface_adapter.add_thread;

import interface_adapter.ViewManagerModel;
import interface_adapter.threads.ThreadsViewModel;
import use_case.add_thread.AddThreadOutputBoundary;
import use_case.add_thread.AddThreadOutputData;

/**
 * The Presenter for the Add Thread Use Case.
 */
public class AddThreadPresenter implements AddThreadOutputBoundary
{
    private final AddThreadViewModel addThreadViewModel;
    private final ThreadsViewModel threadsViewModel;
    private final ViewManagerModel viewManagerModel;

    public AddThreadPresenter(ViewManagerModel viewManagerModel,
                              AddThreadViewModel addThreadViewModel,
                              ThreadsViewModel threadsViewModel)
    {
        this.addThreadViewModel = addThreadViewModel;
        this.threadsViewModel = threadsViewModel;
        this.viewManagerModel = viewManagerModel;
    }

    @Override
    public void prepareSuccessView(AddThreadOutputData outputData, String successMessage)
    {
        // revert add thread view model to blank state
        final AddThreadState state = addThreadViewModel.getState();
        state.setUsernameList("");
        state.setThreadName("");
        state.setAddThreadSuccess(successMessage);
        state.setAddThreadError(null);
        addThreadViewModel.firePropertyChanged("reset-success");

        // update threads view model
        threadsViewModel.getState().addThread(outputData.getThreadID(), outputData.getThreadName());
        threadsViewModel.firePropertyChanged("update-thread-list");

        // switch back to the threads view
        viewManagerModel.setState(threadsViewModel.getViewName());
        viewManagerModel.firePropertyChanged();
    }

    @Override
    public void prepareFailView(String errorMessage)
    {
        final AddThreadState state = addThreadViewModel.getState();
        state.setAddThreadSuccess(null);
        state.setAddThreadError(errorMessage);
        addThreadViewModel.firePropertyChanged();
    }

    @Override
    public void switchToThreadsView()
    {
        viewManagerModel.setState(threadsViewModel.getViewName());
        viewManagerModel.firePropertyChanged();
    }
}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/interface_adapter/add_thread/AddThreadController.java =====
package interface_adapter.add_thread;

import use_case.add_thread.AddThreadInputBoundary;
import use_case.add_thread.AddThreadInputData;

/**
 * Controller for the Add Thread Use Case.
 */
public class AddThreadController
{
    private final AddThreadInputBoundary addThreadUseCaseInteractor;

    public AddThreadController(AddThreadInputBoundary addThreadUseCaseInteractor)
    {
        this.addThreadUseCaseInteractor = addThreadUseCaseInteractor;
    }

    /**
     * Executes the Add Thread use case.
     *
     * @param threadName      the name of the new thread.
     * @param usernameList    is a comma separated string of usernames
     * @param currentUsername the username of the current user of the program
     */
    public void execute(String threadName, String usernameList, String currentUsername)
    {
        AddThreadInputData inputData = new AddThreadInputData(threadName, usernameList, currentUsername);
        addThreadUseCaseInteractor.execute(inputData);
    }

    /**
     * Executes the "switch to ThreadsView" Use Case.
     */
    public void switchToThreadsView()
    {
        addThreadUseCaseInteractor.switchToThreadsView();
    }
}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/interface_adapter/threads/ThreadsViewModel.java =====
package interface_adapter.threads;

import interface_adapter.ViewModel;

/**
 * This model creates the text that is used in the labels for the threads view.
 */
public class ThreadsViewModel extends ViewModel<ThreadsState>
{
    public static final String TITLE_LABEL = "Messages";
    public static final String REFRESH_LABEL = "Refresh";
    public static final String LOGOUT_LABEL = "Logout";
    public static final String ADDTHREAD_LABEL = "New Thread";

    public static final int TITLE_FONT_SIZE = 24;

    // initialize sizes for JObjects
    public static final int TOP_PANEL_LAYOUT_ROWS = 1;
    public static final int TOP_PANEL_LAYOUT_COLUMNS = 2;
    public static final int TOP_BORDER_SPACING = 10;
    public static final int BORDER_SPACING = 40;
    public static final int THREADSLIST_WIDTH = 400;
    public static final int THREADSLIST_HEIGHT = 300;

    public ThreadsViewModel()
    {
        super("threads");
        setState(new ThreadsState());
    }
}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/interface_adapter/threads/GetThreadsController.java =====
package interface_adapter.threads;

import use_case.get_threads.GetThreadsInputBoundary;
import use_case.get_threads.GetThreadsInputData;

/**
 * This is the controller in the clean architecture of the threads view use case.
 */
public class GetThreadsController
{
    private final GetThreadsInputBoundary getThreadsUseCaseInteractor;

    public GetThreadsController(GetThreadsInputBoundary getThreadsUseCaseInteractor)
    {
        this.getThreadsUseCaseInteractor = getThreadsUseCaseInteractor;
    }


    /**
     * Executes the "get threads" Use Case.
     */
    public void execute(String username)
    {
        GetThreadsInputData inputData = new GetThreadsInputData(username);
        getThreadsUseCaseInteractor.execute(inputData);
    }

    /**
     * This switches the current view to the chat view (if the user presses a thread).
     *
     * @param threadID the ID of the thread/chat to switch into
     */
    public void switchToChatView(Long threadID)
    {
        this.getThreadsUseCaseInteractor.switchToChatView(threadID);
    }

    public void switchToAddThreadView()
    {
        this.getThreadsUseCaseInteractor.switchToAddThreadView();
    }
}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/interface_adapter/threads/ThreadsState.java =====
package interface_adapter.threads;

import java.util.HashMap;
import java.util.Map;

/**
 * This class keeps track of the user's username while they are in a logged in state(in the threads view)
 * so that they can log out.
 */
public class ThreadsState
{

    private String currentUsername = "";
    private Map<Long, String> threadHash = new HashMap<>();

    public ThreadsState(ThreadsState copy)
    {
        currentUsername = copy.currentUsername;
        threadHash = copy.threadHash;
    }

    // Because of the previous copy constructor, the default constructor must be explicit.
    public ThreadsState()
    {
    }

    public final String getCurrentUsername()
    {
        return currentUsername;
    }

    public final void setCurrentUsername(String currentUsername)
    {
        this.currentUsername = currentUsername;
    }

    public final Map<Long, String> getThreadHash()
    {
        return threadHash;
    }

    public final void setThreadHash(Map<Long, String> threadHash)
    {
        this.threadHash = threadHash;
    }

    /**
     * Returns an array of thread names from threadHash.
     *
     * @return an array of thread names
     */
    public final String[] getThreadNamesList()
    {
        return threadHash.values().toArray(new String[0]);
    }

    /**
     * Add a thread to the list of threads in this View State.
     *
     * @param threadId   the ID of the added thread
     * @param threadName the name of the added thread
     */
    public final void addThread(Long threadId, String threadName)
    {
        this.threadHash.put(threadId, threadName);
    }

    /**
     * Clears all thread data.
     */
    public final void clearThreadData()
    {
        this.threadHash.clear();
    }

    public final void resetThreadData()
    {
        this.threadHash.clear();
        this.currentUsername = "";
    }
}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/interface_adapter/threads/GetThreadsPresenter.java =====
package interface_adapter.threads;

import entity.Thread;
import interface_adapter.ViewManagerModel;
import interface_adapter.add_thread.AddThreadViewModel;
import interface_adapter.chat_refresh.ChatRefreshController;
import interface_adapter.send_message.ChatState;
import interface_adapter.send_message.ChatViewModel;
import use_case.get_threads.GetThreadsOutputBoundary;
import use_case.get_threads.GetThreadsOutputData;

import java.util.HashMap;
import java.util.Map;

public class GetThreadsPresenter implements GetThreadsOutputBoundary
{
    private final ViewManagerModel viewManagerModel;
    private final ChatViewModel chatViewModel;
    private final ThreadsViewModel threadsViewModel;
    private final AddThreadViewModel addThreadViewModel;
    private final ChatRefreshController chatRefreshController;

    public GetThreadsPresenter(
            ViewManagerModel viewManagerModel,
            ChatViewModel chatViewModel,
            ThreadsViewModel threadsViewModel,
            AddThreadViewModel addThreadViewModel,
            ChatRefreshController chatRefreshController)
    {
        this.viewManagerModel = viewManagerModel;
        this.chatViewModel = chatViewModel;
        this.threadsViewModel = threadsViewModel;
        this.addThreadViewModel = addThreadViewModel;
        this.chatRefreshController = chatRefreshController;
    }

    public void prepareSuccessView(GetThreadsOutputData outputData)
    {
        ThreadsState threadsState = threadsViewModel.getState();
        Map<Long, String> threadMap = new HashMap<>();

        // fill the threadMap with thread data
        for (Thread thread : outputData.getThreads())
        {
            threadMap.put(thread.getThreadID(), thread.getName()); // placeholder for any thread names
        }

        threadsState.setThreadHash(threadMap);
        threadsViewModel.firePropertyChanged("update-thread-list");
    }


    @Override
    public void prepareFailView(String errorMessage)
    {
        ThreadsState threadsState = threadsViewModel.getState();
        threadsState.clearThreadData();
        threadsViewModel.firePropertyChanged("threads-error");
    }

    @Override
    public void switchToChatView(Long threadID)
    {
        // Update chat view model state
        ChatState chatState = chatViewModel.getState();
        chatState.setCurrentThreadID(threadID);
        chatState.setCurrentThreadName(threadsViewModel.getState().getThreadHash().get(threadID));
        chatState.setCurrentUsername(threadsViewModel.getState().getCurrentUsername());
        chatViewModel.setState(chatState);

        // Switch to the chat view
        viewManagerModel.setState(chatViewModel.getViewName());
        viewManagerModel.firePropertyChanged();

        // Automatically refresh chat messages
        chatRefreshController.execute(threadID);
    }

    @Override
    public void switchToAddThreadView()
    {
        // This code tells the View Manager to switch to the AddThreads view.
        viewManagerModel.setState(addThreadViewModel.getViewName());
        viewManagerModel.firePropertyChanged();
    }
}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/interface_adapter/chat_refresh/ChatRefreshPresenter.java =====
package interface_adapter.chat_refresh;

import interface_adapter.send_message.ChatState;
import interface_adapter.send_message.ChatViewModel;
import use_case.chat_refresh.ChatRefreshOutputBoundary;
import use_case.chat_refresh.ChatRefreshOutputData;

public class ChatRefreshPresenter implements ChatRefreshOutputBoundary
{
    private final ChatViewModel chatViewModel;

    public ChatRefreshPresenter(ChatViewModel chatViewModel)
    {
        this.chatViewModel = chatViewModel;
    }

    @Override
    public void prepareSuccessView(ChatRefreshOutputData outputData)
    {
        ChatState chatState = chatViewModel.getState();
        chatState.setAllMessages(outputData.getMessages());
        chatViewModel.setState(chatState);
        chatViewModel.firePropertyChanged("full_message_update");
    }

    @Override
    public void prepareFailView(String errorMessage)
    {
        ChatState chatState = chatViewModel.getState();
        chatState.setSendMessageError(errorMessage);
        chatViewModel.setState(chatState);
        chatViewModel.firePropertyChanged();
    }
}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/interface_adapter/chat_refresh/ChatRefreshController.java =====
package interface_adapter.chat_refresh;

import use_case.chat_refresh.ChatRefreshInputBoundary;
import use_case.chat_refresh.ChatRefreshInputData;

public class ChatRefreshController
{
    private final ChatRefreshInputBoundary chatRefreshInteractor;

    public ChatRefreshController(ChatRefreshInputBoundary chatRefreshInteractor)
    {
        this.chatRefreshInteractor = chatRefreshInteractor;
    }

    public void execute(Long threadID)
    {
        ChatRefreshInputData inputData = new ChatRefreshInputData(threadID);
        chatRefreshInteractor.execute(inputData);
    }
}

===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/interface_adapter/ViewModel.java =====
package interface_adapter;

import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeSupport;

/**
 * The ViewModel for our CA implementation.
 * This class delegates work to a PropertyChangeSupport object for
 * managing the property change events.
 *
 * @param <T> The type of state object contained in the model.
 */
// TODO: overwrite with our code
public class ViewModel<T>
{

    private final String viewName;

    private final PropertyChangeSupport support = new PropertyChangeSupport(this);

    private T state;

    public ViewModel(String viewName)
    {
        this.viewName = viewName;
    }

    public final String getViewName()
    {
        return this.viewName;
    }

    public final T getState()
    {
        return this.state;
    }

    public final void setState(T state)
    {
        this.state = state;
    }

    /**
     * Fires a property changed event for the state of this ViewModel.
     */
    public void firePropertyChanged()
    {
        this.support.firePropertyChange("state", null, this.state);
    }

    /**
     * Fires a property changed event for the state of this ViewModel, which
     * allows the user to specify a different propertyName. This can be useful
     * when a class is listening for multiple kinds of property changes.
     * <p/>
     * For example, the LoggedInView listens for two kinds of property changes;
     * it can use the property name to distinguish which property has changed.
     *
     * @param propertyName the label for the property that was changed
     */
    public void firePropertyChanged(String propertyName)
    {
        this.support.firePropertyChange(propertyName, null, this.state);
    }

    /**
     * Adds a PropertyChangeListener to this ViewModel.
     *
     * @param listener The PropertyChangeListener to be added
     */
    public void addPropertyChangeListener(PropertyChangeListener listener)
    {
        this.support.addPropertyChangeListener(listener);
    }
}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/interface_adapter/login/LoginPresenter.java =====
package interface_adapter.login;

import interface_adapter.ViewManagerModel;
import interface_adapter.add_thread.AddThreadViewModel;
import interface_adapter.send_message.ChatViewModel;
import interface_adapter.signup.SignupViewModel;
import interface_adapter.threads.GetThreadsController;
import interface_adapter.threads.ThreadsViewModel;
import use_case.login.LoginOutputBoundary;
import use_case.login.LoginOutputData;

/**
 * The Presenter for the Login Use Case.
 */
public class LoginPresenter implements LoginOutputBoundary
{
    private final LoginViewModel loginViewModel;
    private final ViewManagerModel viewManagerModel;
    private final SignupViewModel signupViewModel;
    private final ThreadsViewModel threadsViewModel;
    private final ChatViewModel chatViewModel;
    private final AddThreadViewModel addThreadViewModel;
    private final GetThreadsController getThreadsController;

    public LoginPresenter(
            LoginViewModel loginViewModel,
            ViewManagerModel viewManagerModel,
            SignupViewModel signupViewModel,
            ThreadsViewModel threadsViewModel,
            ChatViewModel chatViewModel,
            AddThreadViewModel addThreadViewModel,
            GetThreadsController getThreadsController)
    {
        this.loginViewModel = loginViewModel;
        this.viewManagerModel = viewManagerModel;
        this.signupViewModel = signupViewModel;
        this.threadsViewModel = threadsViewModel;
        this.chatViewModel = chatViewModel;
        this.addThreadViewModel = addThreadViewModel;
        this.getThreadsController = getThreadsController; // Initialize the controller
    }


    @Override
    public void prepareSuccessView(LoginOutputData outputData)
    {
        //Update the LoginViewModel State
        LoginState loginState = loginViewModel.getState();
        loginState.setUsernameOrEmail(outputData.getUsername());
        loginState.setLoginError("");
        loginViewModel.setState(loginState);
        loginViewModel.firePropertyChanged();

        // Update the Current Username in each ViewModel
        threadsViewModel.getState().setCurrentUsername(outputData.getUsername());
        threadsViewModel.firePropertyChanged();

        chatViewModel.getState().setCurrentUsername(outputData.getUsername());
        chatViewModel.firePropertyChanged();

        addThreadViewModel.getState().setCurrentUsername(outputData.getUsername());
        addThreadViewModel.firePropertyChanged();

        // Switch to the ThreadsView
        viewManagerModel.setState(threadsViewModel.getViewName());
        viewManagerModel.firePropertyChanged();

        // Automatically refresh threads
        getThreadsController.execute(outputData.getUsername());
    }

    @Override
    public void prepareFailView(String errorMessage)
    {
        //Update the LoginViewModel State
        LoginState loginState = loginViewModel.getState();
        loginState.setLoginError(errorMessage);
        loginViewModel.setState(loginState);
        loginViewModel.firePropertyChanged();
    }

    @Override
    public void switchToSignUpView()
    {
        //Switch to the SignUpView
        viewManagerModel.setState(signupViewModel.getViewName());
        viewManagerModel.firePropertyChanged();
    }
}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/interface_adapter/login/LoginViewModel.java =====
package interface_adapter.login;

import interface_adapter.ViewModel;

/**
 * The View Model for the Login View.
 */
public class LoginViewModel extends ViewModel<LoginState>
{

    public LoginViewModel()
    {
        super("log in");
        setState(new LoginState());
    }

}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/interface_adapter/login/LoginState.java =====
package interface_adapter.login;

/**
 * The state for the Login View Model.
 */
public final class LoginState
{
    private String usernameOrEmail = "";
    private String loginError;
    private String password = "";

    public String getUsernameOrEmail()
    {
        return usernameOrEmail;
    }

    public void setUsernameOrEmail(String usernameOrEmail)
    {
        this.usernameOrEmail = usernameOrEmail;
    }

    public String getLoginError()
    {
        return loginError;
    }

    public void setLoginError(String usernameError)
    {
        this.loginError = usernameError;
    }

    public String getPassword()
    {
        return password;
    }

    public void setPassword(String password)
    {
        this.password = password;
    }

}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/interface_adapter/login/LoginController.java =====
package interface_adapter.login;

import use_case.login.LoginInputBoundary;
import use_case.login.LoginInputData;

/**
 * The controller for the Login Use Case.
 */
public class LoginController
{

    private final LoginInputBoundary loginUseCaseInteractor;

    public LoginController(LoginInputBoundary loginUseCaseInteractor)
    {
        this.loginUseCaseInteractor = loginUseCaseInteractor;
    }

    /**
     * Executes the Login Use Case.
     *
     * @param usernameOrEmail the username or email of the user logging in
     * @param password        the password of the user logging in
     */
    public void execute(String usernameOrEmail, String password)
    {
        final LoginInputData loginInputData = new LoginInputData(usernameOrEmail, password);

        loginUseCaseInteractor.execute(loginInputData);
    }

    public void switchToSignUpView()
    {
        this.loginUseCaseInteractor.switchToSignUpView();
    }
}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/app/AppBuilder.java =====
package app;

import data_access.MessageDataAccessObject;
import data_access.PingBackend;
import data_access.ThreadDataAccessObject;
import data_access.UserDataAccessObject;
import entity.MessageFactory;
import entity.ThreadFactory;
import entity.UserFactory;
import interface_adapter.ViewManagerModel;
import interface_adapter.add_thread.AddThreadController;
import interface_adapter.add_thread.AddThreadPresenter;
import interface_adapter.add_thread.AddThreadViewModel;
import interface_adapter.chat_refresh.ChatRefreshController;
import interface_adapter.chat_refresh.ChatRefreshPresenter;
import interface_adapter.login.LoginController;
import interface_adapter.login.LoginPresenter;
import interface_adapter.login.LoginViewModel;
import interface_adapter.logout.LogoutController;
import interface_adapter.logout.LogoutPresenter;
import interface_adapter.send_message.ChatViewModel;
import interface_adapter.send_message.SendMessageController;
import interface_adapter.send_message.SendMessagePresenter;
import interface_adapter.signup.SignupController;
import interface_adapter.signup.SignupPresenter;
import interface_adapter.signup.SignupViewModel;
import interface_adapter.threads.GetThreadsController;
import interface_adapter.threads.GetThreadsPresenter;
import interface_adapter.threads.ThreadsViewModel;
import use_case.add_thread.AddThreadInputBoundary;
import use_case.add_thread.AddThreadInteractor;
import use_case.add_thread.AddThreadOutputBoundary;
import use_case.chat_refresh.ChatRefreshInputBoundary;
import use_case.chat_refresh.ChatRefreshInteractor;
import use_case.chat_refresh.ChatRefreshOutputBoundary;
import use_case.get_threads.GetThreadsInputBoundary;
import use_case.get_threads.GetThreadsOutputBoundary;
import use_case.get_threads.GetThreadsUseCaseInteractor;
import use_case.login.LoginInputBoundary;
import use_case.login.LoginInteractor;
import use_case.login.LoginOutputBoundary;
import use_case.logout.LogoutInputBoundary;
import use_case.logout.LogoutInteractor;
import use_case.logout.LogoutOutputBoundary;
import use_case.send_message.SendMessageInputBoundary;
import use_case.send_message.SendMessageInteractor;
import use_case.send_message.SendMessageOutputBoundary;
import use_case.signup.SignupInputBoundary;
import use_case.signup.SignupInteractor;
import use_case.signup.SignupOutputBoundary;
import view.*;

import javax.swing.*;
import java.awt.*;

/**
 * The AppBuilder class is responsible for putting together the pieces of
 * our Clean Architecture; piece by piece.
 * <p/>
 * This is done by adding each View and then adding related Use Cases.
 */
public class AppBuilder
{

    private final JPanel cardPanel = new JPanel();
    private final CardLayout cardLayout = new CardLayout();
    private final UserFactory userFactory = new UserFactory();
    private final MessageFactory messageFactory = new MessageFactory();
    private final ThreadFactory threadFactory = new ThreadFactory();
    private final ViewManagerModel viewManagerModel = new ViewManagerModel();
    private final ViewManager viewManager = new ViewManager(cardPanel, cardLayout, viewManagerModel);

    // Create the Backend instance
    PingBackend pingBackend = new PingBackend("http://pingserver-env.eba-u7hgzajj.ca-central-1.elasticbeanstalk.com/");
    private final UserDataAccessObject userDataAccessObject = new UserDataAccessObject(pingBackend);
    private final ThreadDataAccessObject threadDataAccessObject = new ThreadDataAccessObject(pingBackend);
    private final MessageDataAccessObject messageDataAccessObject = new MessageDataAccessObject(pingBackend);

    private SignupView signupView;
    private SignupViewModel signupViewModel;
    private LoginViewModel loginViewModel;
    private ChatViewModel chatViewModel;
    private ThreadsViewModel threadsViewModel;
    private AddThreadViewModel addThreadViewModel;
    private LoginView loginView;
    private ChatView chatView;
    private ThreadsView threadsView;
    private AddThreadView addThreadView;

    // Declare controllers as instance variables
    private ChatRefreshController chatRefreshController;
    private GetThreadsController getThreadsController;

    public AppBuilder()
    {
        cardPanel.setLayout(cardLayout);
    }

    // == ADD THE VIEWS ==

    /**
     * Adds the Signup View to the application.
     *
     * @return this builder
     */
    public AppBuilder addSignupView()
    {
        signupViewModel = new SignupViewModel();
        signupView = new SignupView(signupViewModel);
        cardPanel.add(signupView, signupView.getViewName());
        return this;
    }

    /**
     * Adds the Login View to the application.
     *
     * @return this builder
     */
    public AppBuilder addLoginView()
    {
        loginViewModel = new LoginViewModel();
        loginView = new LoginView(loginViewModel);
        cardPanel.add(loginView, loginView.getViewName());
        return this;
    }

    /**
     * Adds the Threads View to the application.
     *
     * @return this builder
     */
    public AppBuilder addThreadsView()
    {
        threadsViewModel = new ThreadsViewModel();
        threadsView = new ThreadsView(threadsViewModel);
        cardPanel.add(threadsView, threadsView.getViewName());
        return this;
    }

    /**
     * Adds the ChatView to the application.
     * This Chat View will be empty at the moment and will be updated depending on which Thread is opened.
     *
     * @return this builder
     */
    public AppBuilder addChatView()
    {
        chatViewModel = new ChatViewModel();
        chatView = new ChatView(chatViewModel);
        cardPanel.add(chatView, chatView.getViewName());
        return this;
    }

    /**
     * Adds the Add Threads View to the application.
     *
     * @return this builder
     */
    public AppBuilder addAddThreadsView()
    {
        addThreadViewModel = new AddThreadViewModel();
        addThreadView = new AddThreadView(addThreadViewModel);
        cardPanel.add(addThreadView, addThreadView.getViewName());
        return this;
    }

    // == ADD THE USE CASES ==

    /**
     * Adds the Send Message Use Case to the application.
     *
     * @return this builder
     */
    public AppBuilder addSendMessageUseCase()
    {
        final SendMessageOutputBoundary sendMessageOutputBoundary = new SendMessagePresenter(
                viewManagerModel, chatViewModel, threadsViewModel);
        final SendMessageInputBoundary sendMessageInteractor = new SendMessageInteractor(
                messageDataAccessObject, messageFactory, sendMessageOutputBoundary);

        final SendMessageController controller = new SendMessageController(sendMessageInteractor);
        chatView.setSendMessageController(controller);
        return this;
    }

    /**
     * Adds the Signup Use Case to the application.
     *
     * @return this builder
     */
    public AppBuilder addSignupUseCase()
    {
        final SignupOutputBoundary signupOutputBoundary = new SignupPresenter(
                viewManagerModel, signupViewModel, loginViewModel);

        final SignupInputBoundary signupInteractor = new SignupInteractor(
                userDataAccessObject, signupOutputBoundary, userFactory);

        final SignupController signupController = new SignupController(signupInteractor);
        signupView.setSignupController(signupController);
        return this;
    }

    /**
     * Adds the Login Use Case to the application.
     * Note: Ensure that getThreadsController is initialized before this method is called.
     *
     * @return this builder
     */
    public AppBuilder addLoginUseCase()
    {
        final LoginOutputBoundary loginOutputBoundary = new LoginPresenter(
                loginViewModel, viewManagerModel, signupViewModel, threadsViewModel,
                chatViewModel, addThreadViewModel, getThreadsController); // Pass getThreadsController here

        final LoginInputBoundary loginInteractor = new LoginInteractor(
                userDataAccessObject, loginOutputBoundary);

        final LoginController loginController = new LoginController(loginInteractor);
        loginView.setLoginController(loginController);
        return this;
    }

    /**
     * Adds the Logout Use Case to the application.
     *
     * @return this builder
     */
    public AppBuilder addLogoutUseCase()
    {
        final LogoutOutputBoundary logoutOutputBoundary = new LogoutPresenter(
                viewManagerModel, loginViewModel, threadsViewModel, chatViewModel);

        final LogoutInputBoundary logoutInteractor = new LogoutInteractor(
                userDataAccessObject, logoutOutputBoundary);

        final LogoutController logoutController = new LogoutController(logoutInteractor);
        threadsView.setLogoutController(logoutController);
        return this;
    }

    /**
     * Adds the Get Threads Use Case to the application.
     * Note: Ensure that chatRefreshController is initialized before this method is called.
     *
     * @return this builder
     */
    public AppBuilder addGetThreadsUseCase()
    {
        final GetThreadsOutputBoundary getThreadsOutputBoundary = new GetThreadsPresenter(
                viewManagerModel, chatViewModel, threadsViewModel, addThreadViewModel,
                chatRefreshController); // Pass chatRefreshController here

        final GetThreadsInputBoundary getThreadsInteractor = new GetThreadsUseCaseInteractor(
                threadDataAccessObject, getThreadsOutputBoundary);

        this.getThreadsController = new GetThreadsController(getThreadsInteractor);
        threadsView.setGetThreadsController(getThreadsController);

        return this;
    }

    /**
     * Adds the Add Thread Use Case to the application.
     *
     * @return this builder
     */
    public AppBuilder addAddThreadUseCase()
    {
        final AddThreadOutputBoundary addThreadOutputBoundary = new AddThreadPresenter(
                viewManagerModel, addThreadViewModel, threadsViewModel);

        final AddThreadInputBoundary addThreadInteractor = new AddThreadInteractor(
                threadDataAccessObject, addThreadOutputBoundary, threadFactory);

        final AddThreadController controller = new AddThreadController(addThreadInteractor);
        addThreadView.setAddThreadController(controller);
        return this;
    }

    /**
     * Adds the Chat Refresh Use Case to the application.
     *
     * @return this builder
     */
    public AppBuilder addChatRefreshUseCase()
    {
        final ChatRefreshOutputBoundary chatRefreshPresenter = new ChatRefreshPresenter(chatViewModel);
        final ChatRefreshInputBoundary chatRefreshInteractor = new ChatRefreshInteractor(
                messageDataAccessObject, chatRefreshPresenter);

        this.chatRefreshController = new ChatRefreshController(chatRefreshInteractor);
        chatView.setChatRefreshController(chatRefreshController);
        return this;
    }

    /**
     * Creates the JFrame for the application and initially sets the SignupView to be displayed.
     *
     * @return the application
     */
    public JFrame build()
    {
        // Build order matters to ensure controllers are initialized before use
        this.addLoginView()
                .addSignupView()
                .addThreadsView()
                .addChatView()
                .addAddThreadsView()
                .addChatRefreshUseCase()  // Initialize chatRefreshController
                .addGetThreadsUseCase()   // Initialize getThreadsController after chatRefreshController
                .addSendMessageUseCase()
                .addSignupUseCase()
                .addLoginUseCase()        // Now that getThreadsController is initialized
                .addLogoutUseCase()
                .addAddThreadUseCase();

        final JFrame application = new JFrame("Ping Chat");
        application.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);

        // Set the size of the JFrame to 500 by 400 pixels
        application.setSize(500, 400);

        // Center the window on the screen
        application.setLocationRelativeTo(null);

        // Add the card panel to the JFrame
        application.add(cardPanel);

        // Set the initial view to the SignupView
        viewManagerModel.setState(signupView.getViewName());
        viewManagerModel.firePropertyChanged();

        // Make the window visible
        application.setVisible(true);

        return application;
    }
}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/app/Main.java =====
package app;

import javax.swing.*;

/**
 * The Main class of our application.
 */
public class Main
{
    /**
     * Builds and runs the CA architecture of the application.
     *
     * @param args unused arguments
     */
    public static void main(String[] args)
    {
        final AppBuilder appBuilder = new AppBuilder();
        final JFrame application = appBuilder
                .addLoginView()
                .addSignupView()
                .addThreadsView()
                .addChatView()
                .addAddThreadsView()
                .addSendMessageUseCase()
                .addGetThreadsUseCase()
                .addSignupUseCase()
                .addLoginUseCase()
                .addLogoutUseCase()
                .addAddThreadUseCase()
                .addChatRefreshUseCase()
                .build();

        application.pack();
        application.setVisible(true);

        // TODO: helps with debugging, will remove later
        System.out.println("Application running");
    }
}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/data_access/ThreadDataAccessObject.java =====
package data_access;

import java.io.IOException;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import org.json.JSONArray;
import org.json.JSONObject;

import entity.Message;
import entity.Thread;
import use_case.add_thread.AddThreadThreadDataAccessInterface;
import use_case.get_threads.GetThreadsThreadDataAccessInterface;

/**
 * The DAO for thread data.
 */
public class ThreadDataAccessObject implements AddThreadThreadDataAccessInterface, GetThreadsThreadDataAccessInterface
{
    private static final String PARTICIPANTS = "participants";
    private final PingBackend backend;

    public ThreadDataAccessObject(PingBackend backend)
    {
        this.backend = backend;
    }

    // very similar logic throughout these three methods
    @Override
    public List<Long> getUserThreadIDs(Long userID)
    {
        try
        {
            JSONObject response = backend.getThreads();
            JSONArray threadsArray = response.getJSONArray("threads");

            List<Long> threadIDs = new ArrayList<>();
            for (int i = 0; i < threadsArray.length(); i++)
            {
                JSONObject threadJson = threadsArray.getJSONObject(i);
                threadIDs.add(threadJson.getLong("id"));
            }
            return threadIDs;
        }
        catch (Exception exception)
        {
            throw new RuntimeException("Failed to fetch thread IDs", exception);
        }
    }

    @Override
    public List<Thread> getThreads(List<Long> threadIDs)
    {
        try
        {
            JSONObject response = backend.getThreads();
            JSONArray threadsArray = response.getJSONArray("threads");

            List<Thread> threads = new ArrayList<>();
            for (int i = 0; i < threadsArray.length(); i++)
            {
                JSONObject threadJson = threadsArray.getJSONObject(i);
                Long threadID = threadJson.getLong("threadId");

                if (threadIDs.contains(threadID))
                {
                    String name = threadJson.getString("threadName");
                    Thread thread = new Thread(threadID, name);
                    threads.add(thread);
                }
            }
            return threads;
        }
        catch (Exception exception)
        {
            throw new RuntimeException("Failed to fetch threads", exception);
        }
    }

    @Override
    public List<Thread> getThreadsByUsername(String username)
    {
        try
        {
            JSONObject response = backend.getThreads();
            JSONArray threadsArray = response.getJSONArray("threads");

            List<Thread> userThreads = new ArrayList<>();

            for (int i = 0; i < threadsArray.length(); i++)
            {
                JSONObject threadJson = threadsArray.getJSONObject(i);
                JSONArray participantsArray = threadJson.getJSONArray("participants");

                if (participantsArray.toList().contains(username))
                {
                    Long threadID = threadJson.getLong("threadId");
                    String name = threadJson.getString("threadName");

                    Thread thread = new Thread(threadID, name);
                    userThreads.add(thread);
                }
            }

            return userThreads;
        }
        catch (Exception exception)
        {
            throw new RuntimeException("Failed to fetch threads for username: " + username, exception);
        }
    }

    @Override
    public Thread save(Thread thread) throws Exception
    {
        // Send a request to the server to create a new thread
        JSONObject serverOutput = backend.createThread(
                thread.getName(), thread.getUsernameList().toArray(new String[0]));

        // if it's the error JSON object:
        if (serverOutput.has("error"))
        {
            // Throw an exception with the server error message
            String errorMessage = serverOutput.getString("message");
            throw new IOException("Server Error: " + errorMessage);
        }

        // If the outputted usernameList contains the same username twice
        if (hasDuplicateUsernames(serverOutput))
        {
            throw new IllegalArgumentException(
                    "Duplicate or self-included usernames found in the participant list.");
        }

        // Parse the successful response and create a new Thread object
        if (serverOutput.has("threadId") && serverOutput.has("threadName") && serverOutput.has(
                PARTICIPANTS))
        {
            Long threadID = serverOutput.getLong("threadId");
            String threadName = serverOutput.getString("threadName");
            List<String> usernameList = new ArrayList<>();
            JSONArray participantArray = serverOutput.getJSONArray(PARTICIPANTS);
            for (int i = 0; i < participantArray.length(); i++)
            {
                usernameList.add(participantArray.getString(i));
            }
            List<Message> emptyMessageList = new ArrayList<>();

            // Return the new Thread object with an empty messageList
            return new Thread(threadName, usernameList, emptyMessageList, threadID);
        }

        // If the response doesn't match either expected format, throw an exception
        throw new IOException("Unexpected server response: " + serverOutput);
    }

    private boolean hasDuplicateUsernames(JSONObject serverOutput)
    {
        if (serverOutput.has(PARTICIPANTS))
        {
            JSONArray participants = serverOutput.getJSONArray(PARTICIPANTS);
            Set<String> uniqueUsernames = new HashSet<>();
            for (int i = 0; i < participants.length(); i++)
            {
                String username = participants.getString(i);
                if (!uniqueUsernames.add(username))
                {
                    // If add() returns false, a duplicate username was found
                    return true;
                }
            }
        }
        return false;
    }
}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/data_access/PingBackend.java =====
package data_access;

import org.json.JSONObject;

/**
 * Object for making calls to the Ping Backend Server.
 */
public class PingBackend extends AbstractAPICall
{
    private static final String POST = "POST";
    private static final String GET = "GET";

    // Class Constructor
    public PingBackend(String serverURL)
    {
        super(serverURL);
    }

    /**
     * Method used to register a new account.
     *
     * @param username of the new user
     * @param email    of the new user
     * @param password of the new user
     * @return the state of success of the call
     * @throws Exception if api call goes wrong.
     */
    public String register(String username, String email, String password) throws Exception
    {
        // Construct the body
        JSONObject body = new JSONObject();
        body.put("username", username);
        body.put("email", email);
        body.put("password", password);

        // Call API
        return sendRequest("api/v1/auth/register", POST, body);
    }

    /**
     * Method used to log in a user.
     * @param usernameOrEmail username
     * @param password password
     * @return the state of success of the call
     * @throws Exception if api call goes wrong
     */
    public JSONObject login(String usernameOrEmail, String password) throws Exception
    {
        try
        {
            // Construct the body
            JSONObject body = new JSONObject();
            body.put("usernameOrEmail", usernameOrEmail);
            body.put("password", password);

            // Call API
            String response = sendRequest("api/v1/auth/login", "POST", body);

            // Parse the response as a JSON object
            JSONObject responseJSON = new JSONObject(response);

            if (responseJSON.has("authToken"))
            {
                this.setAccessToken(responseJSON.optString("authToken"));
            }

            // Return results as a JSON
            return responseJSON;
        }
        catch (Exception exception)
        {
            System.out.println("Login failed: " + exception.getMessage());
            throw exception;
        }
    }

    /**
     * Method to save a new thread in the server.
     *
     * @param threadName           the name of the thread to be created
     * @param participantUsernames the users in the thread to be created
     * @return a json object with all the data needed to create a Thread object
     * @throws Exception if the API call goes wrong
     */
    public JSONObject createThread(String threadName, String[] participantUsernames) throws Exception
    {
        // Construct the body
        JSONObject body = new JSONObject();
        body.put("threadName", threadName);
        body.put("threadName", threadName);
        body.put("participants", participantUsernames);

        // Call API
        String response = sendRequest("api/v1/threads", POST, body);
        // Return results as a JSON
        return new JSONObject(response);
    }

    /**
     * Method to save a new message in the server, within a thread.
     *
     * @param threadId    the ID of the thread to associate the message with
     * @param messageType the ype of the message to save
     * @param content     the content of the message to save
     * @return a json object with all the data needed to create a Message object
     * @throws Exception if the API call goes wrong
     */
    public JSONObject sendMessage(int threadId, String messageType, String content) throws Exception
    {
        // Construct the body
        JSONObject body = new JSONObject();
        body.put("threadId", threadId);
        body.put("messageType", messageType);
        body.put("content", content);

        // Call API
        String response = sendRequest("api/v1/messages", POST, body);
        // Return results as a JSON
        return new JSONObject(response);
    }

    /**
     * Method to get all the messages in a given thread.
     *
     * @param threadId the ID of the thread to get messages from
     * @return a json object with a list of message data necessary to create a List of Message objects
     * @throws Exception if the API call goes wrong
     */
    public JSONObject getMessages(int threadId) throws Exception
    {
        // Call API
        String response = sendRequest("api/v1/messages/" + threadId, GET, null);
        System.out.println(response);
        // Return results as a JSON
        return new JSONObject(response);
    }

    /**
     * Method to get all the threads currently saved in the server.
     *
     * @return a json object with...
     * @throws Exception if the API call goes wrong
     */
    public JSONObject getThreads() throws Exception
    {
        // Call API
        String response = sendRequest("api/v1/threads", GET, null);
        System.out.println(response);
        // Return results as a JSON
        return new JSONObject(response);
    }

    /**
     * Returns "Hello World".
     *
     * @return "Hello World"
     * @throws Exception if the API call goes wrong
     */
    public String helloWorld() throws Exception
    {
        // Call API and Return
        return sendRequest("api/hello", GET, null);
    }

    /**
     * This deletes the user's access token when the user logs out.
     */
    public void logout()
    {

        this.setAccessToken(null);
    }
}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/data_access/UserDataAccessObject.java =====
package data_access;

import java.io.IOException;

import org.json.JSONException;
import org.json.JSONObject;

import entity.User;
import use_case.login.LoginUserDataAccessInterface;
import use_case.logout.LogoutUserDataAccessInterface;
import use_case.signup.SignupUserDataAccessInterface;

/**
 * The DAO for user data.
 */
public class UserDataAccessObject implements
        SignupUserDataAccessInterface,
        LoginUserDataAccessInterface,
        LogoutUserDataAccessInterface
{
    private final PingBackend backend;

    public UserDataAccessObject(PingBackend backend)
    {
        this.backend = backend;
    }

    @Override
    public boolean existsByName(String username)
    {
        return false;
    }

    @Override
    public JSONObject validateCredentials(String email, String password)
    {
        try
        {
            JSONObject response = backend.login(email, password);
            return response;
        }
        catch (Exception exception)
        {
            System.out.println(exception.getMessage());
            throw new RuntimeException(exception);
        }
    }

    @Override
    public void save(User user) throws Exception
    {
        try
        {
            String response = backend.register(user.getUsername(), user.getEmail(), user.getPassword());
            JSONObject jsonResponse = new JSONObject(response);

            if (jsonResponse.has("error"))
            {
                // Server returned an error; throw an exception with the error message
                throw new Exception(jsonResponse.getString("message"));
            }
            // If no error, registration was successful
        }
        catch (IOException ioException)
        {
            // Handle network errors
            throw new Exception("Network error occurred while registering. Please check your connection.");
        }
        catch (JSONException jsonException)
        {
            // Handle JSON parsing errors
            throw new Exception("Unexpected server response. Please try again later.");
        }
        catch (Exception exception)
        {
            // General exception
            throw new Exception("An error occurred during registration: " + exception.getMessage());
        }
    }

    @Override
    public User get(String username)
    {
        return null;
    }

    @Override
    public String getCurrentUsername()
    {
        return "";
    }

    @Override
    public void setCurrentUsername(String username)
    {
    }

    @Override
    public void logout()
    {
        this.backend.logout();
    }
}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/data_access/AbstractAPICall.java =====
package data_access;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.net.HttpURLConnection;
import java.net.URL;

import org.json.JSONObject;

/**
 * Abstract class containing the logic to make API calls.
 */
public abstract class AbstractAPICall
{
    private String accessToken = null;
    private String serverURL = "http://pingserver-env.eba-u7hgzajj.ca-central-1.elasticbeanstalk.com/";

    public AbstractAPICall(String serverURL)
    {
        if (serverURL != null)
        {
            this.serverURL = serverURL;
        }
    }

    /**
     * Logic to send a request to the server.
     *
     * @param endpoint [description here]
     * @param method   [description here]
     * @param body     [description here]
     * @return [description here]
     * @throws Exception if the API call goes wrong
     */
    public String sendRequest(String endpoint, String method, JSONObject body) throws Exception
    {
        URL url = new URL(serverURL + endpoint);
        HttpURLConnection conn = (HttpURLConnection) url.openConnection();
        conn.setRequestMethod(method);
        conn.setRequestProperty("Content-Type", "application/json");

        if (accessToken != null)
        {
            conn.setRequestProperty("Authorization", "Bearer " + accessToken);
        }

        if (body != null)
        {
            conn.setDoOutput(true);
            try (OutputStream os = conn.getOutputStream())
            {
                os.write(body.toString().getBytes());
                os.flush();
            }
        }

        int responseCode = conn.getResponseCode();
        BufferedReader reader = new BufferedReader(
                new InputStreamReader(responseCode >= 200 && responseCode < 300
                        ? conn.getInputStream()
                        : conn.getErrorStream())
        );
        StringBuilder response = new StringBuilder();
        String line;
        while ((line = reader.readLine()) != null)
        {
            response.append(line);
        }
        reader.close();

        return response.toString();
    }

    public final String getAccessToken()
    {
        return accessToken;
    }

    public final void setAccessToken(String accessToken)
    {
        this.accessToken = accessToken;
    }
}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/data_access/MessageDataAccessObject.java =====
package data_access;

import java.io.IOException;
import java.time.Instant;
import java.time.ZoneId;
import java.time.ZonedDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.List;

import org.json.JSONArray;
import org.json.JSONObject;

import entity.Message;
import use_case.chat_refresh.ChatRefreshThreadDataAccessInterface;
import use_case.send_message.SendMessageMessageDataAccessInterface;

/**
 * The DAO for message data.
 */
public class MessageDataAccessObject implements
        SendMessageMessageDataAccessInterface,
        ChatRefreshThreadDataAccessInterface
{
    private final PingBackend backend;

    public MessageDataAccessObject(PingBackend backend)
    {
        this.backend = backend;
    }

    @Override
    public List<Message> getMessages(Long threadID) throws Exception
    {
        JSONObject response = backend.getMessages(threadID.intValue());
        JSONArray messagesArray = response.getJSONArray("messages");

        List<Message> messages = new ArrayList<>();
        for (int i = 0; i < messagesArray.length(); i++)
        {
            JSONObject messageJson = messagesArray.getJSONObject(i);
            String sender = messageJson.getString("sender");
            String content = messageJson.getString("content");
            String timestamp = formatTimestamp(messageJson.getString("timestamp"));
            Message message = new Message(content, sender, timestamp);
            messages.add(message);
        }
        return messages;
    }


    @Override
    public Message save(Message message, Long threadID) throws Exception
    {
        // Send a request to the server to save the new message
        JSONObject serverOutput = backend.sendMessage(
                Math.toIntExact(threadID), "text", message.getContent());

        // If it's the error JSON object:
        if (serverOutput.has("error"))
        {
            // Throw an exception with the server error message
            String errorMessage = serverOutput.getString("message");
            throw new IOException("Server Error: " + errorMessage);
        }

        // Parse the successful response and create a new Message object
        if (serverOutput.has("sender") && serverOutput.has("messageId")
                && serverOutput.has("content") && serverOutput.has("timestamp"))
        {
            String sender = serverOutput.getString("sender");
            String content = serverOutput.getString("content");
            String timestamp = formatTimestamp(serverOutput.getString("timestamp"));

            return new Message(content, sender, timestamp);
        }

        // If the response doesn't match either expected format, throw an exception
        throw new IOException("Unexpected server response: " + serverOutput);
    }

    private static String formatTimestamp(String isoTimestamp)
    {
        ZoneId torontoTimeZone = ZoneId.of("America/Toronto");
        Instant instant = Instant.parse(isoTimestamp);
        ZonedDateTime torontoTime = instant.atZone(torontoTimeZone);
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd | h:mm a");
        return torontoTime.format(formatter);
    }
}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/entity/MessageFactory.java =====
package entity;

/**
 * Factory for creating messages.
 */
public class MessageFactory
{
    /**
     * This method creates a new message object, with its timestamp set to null.
     *
     * @param content        content of the message
     * @param senderUsername the username of the sender
     * @return a new user object
     */
    public Message create(String content, String senderUsername)
    {
        return new Message(content, senderUsername);
    }
}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/entity/Message.java =====
package entity;

/**
 * The representation of a message in our program.
 */
public class Message
{
    public static final int MESSAGE_MAX_LENGTH = 280;

    private final String senderUsername;
    private final String content;
    private final String timestamp;

    public Message(String content, String senderUsername)
    {
        this.content = content;
        this.senderUsername = senderUsername;
        this.timestamp = null;
    }

    public Message(String content, String senderUsername, String timestamp)
    {
        this.content = content;
        this.senderUsername = senderUsername;
        this.timestamp = timestamp;
    }

    public final String getContent()
    {
        return content;
    }

    public final String getSenderUsername()
    {
        return senderUsername;
    }

    public final String getTimestamp()
    {
        return timestamp;
    }
}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/entity/User.java =====
package entity;

/**
 * The representation of a user in our program.
 */
public class User
{
    private final String username;
    private final String email;
    private final String password;

    public User(String username, String password, String email)
    {
        this.username = username;
        this.email = email;
        this.password = password;
    }

    public User(String username)
    {
        this.username = username;
        this.email = null;
        this.password = null;
    }

    public final String getEmail()
    {
        return this.email;
    }

    public final String getUsername()
    {
        return this.username;
    }

    public final String getPassword()
    {
        return password;
    }
}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/entity/ThreadFactory.java =====
package entity;

import java.util.ArrayList;
import java.util.List;

/**
 * Factory for creating threads.
 */
public class ThreadFactory
{

    /**
     * This method creates a new thread object.
     *
     * @param name               the name of the new thread
     * @param usernameListString comma separated string of usernames
     * @return a new Thread object
     */
    public Thread create(String name, String usernameListString)
    {
        List<String> usernameList = convertCommaSeparatedToList(usernameListString);
        return new Thread(name, usernameList);
    }

    private List<String> convertCommaSeparatedToList(String usernameListString)
    {
        final List<String> result = new ArrayList<>();

        if (usernameListString != null && !usernameListString.isEmpty())
        {
            String[] parts = usernameListString.split(",");
            for (String part : parts)
            {
                result.add(part.trim());
            }
        }
        return result;
    }

}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/entity/Thread.java =====
package entity;

import java.util.ArrayList;
import java.util.List;

/**
 * The representation of a thread in our program.
 */
public class Thread
{
    public static final int THREAD_NAME_MAX_LENGTH = 100;
    public static final int THREAD_NAME_MIN_LENGTH = 3;

    private final Long threadID;
    private final List<String> usernameList;
    private final List<Message> messageList;
    private String name;

    // Constructor for the creation of a new Thread with no messages.
    public Thread(String name, List<String> usernameList)
    {
        this.name = name;
        this.usernameList = usernameList;
        this.messageList = new ArrayList<>();
        this.threadID = null;
    }

    // Constructor for a Thread that already exists in the database
    public Thread(String name, List<String> usernameList, List<Message> messageList, Long threadID)
    {
        this.name = name;
        this.usernameList = usernameList;
        this.messageList = messageList;
        this.threadID = threadID;
    }

    // New Constructor for threads fetched from the backend.
    public Thread(Long threadID, String name)
    {
        this.threadID = threadID;
        this.name = name;
        this.usernameList = new ArrayList<>();
        this.messageList = new ArrayList<>();
    }

    public final String getName()
    {
        return this.name;
    }

    public final void setName(String newName)
    {
        this.name = newName;
    }

    public final List<String> getUsernameList()
    {
        return this.usernameList;
    }

    public final Long getThreadID()
    {
        return this.threadID;
    }

    public final List<Message> getMessageList()
    {
        return messageList;
    }

    @Override
    public String toString()
    {
        return "Thread{" + "threadID=" + threadID + ", name='" + name + '\'' + ", usernameList=" + usernameList
                + ", messageList=" + messageList + '}';
    }
}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/entity/UserFactory.java =====
package entity;

/**
 * Factory for creating users.
 */
public class UserFactory
{

    /**
     * This method creates a new user object.
     *
     * @param name     of user
     * @param password password of the user
     * @param email    email of the user
     * @return a new user object
     */
    public User create(String name, String password, String email)
    {
        return new User(name, password, email);
    }
}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/use_case/get_threads/GetThreadsOutputData.java =====
package use_case.get_threads;

import entity.Thread;

import java.util.List;

public class GetThreadsOutputData
{
    private List<Thread> threads;

    public GetThreadsOutputData(List<Thread> threads)
    {
        this.threads = threads;
    }

    public List<Thread> getThreads()
    {
        return threads;
    }

}

===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/use_case/get_threads/GetThreadsUserDataAccessInterface.java =====
package use_case.get_threads;

public interface GetThreadsUserDataAccessInterface
{
    /**
     * Fetch the ID of the currently authenticated user.
     *
     * @return Current user's ID.
     */
    Long getCurrentUserID();
}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/use_case/get_threads/GetThreadsThreadDataAccessInterface.java =====
package use_case.get_threads;

import entity.Thread;

import java.util.List;

public interface GetThreadsThreadDataAccessInterface
{
    /**
     * Fetch all thread IDs associated with the given user.
     *
     * @param userID The ID of the user.
     * @return List of thread IDs.
     */
    List<Long> getUserThreadIDs(Long userID);

    /**
     * Fetch all threads for the current user.
     *
     * @return List of threads.
     */
    List<Thread> getThreads(List<Long> threadIDs);

    List<Thread> getThreadsByUsername(String username);

}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/use_case/get_threads/GetThreadsUseCaseInteractor.java =====
package use_case.get_threads;


import entity.Thread;

import java.util.List;

/**
 * The get threads Interactor.
 */
public class GetThreadsUseCaseInteractor implements GetThreadsInputBoundary
{
    private final GetThreadsThreadDataAccessInterface threadDataAccess;
    private final GetThreadsOutputBoundary presenter;

    // == CONSTRUCTOR ==
    public GetThreadsUseCaseInteractor(GetThreadsThreadDataAccessInterface threadDataAccess,
                                       GetThreadsOutputBoundary presenter)
    {
        this.threadDataAccess = threadDataAccess;
        this.presenter = presenter;
    }

    // == USE CASE METHODS ==

    // main use case method
    @Override
    public void execute(GetThreadsInputData inputData)
    {
        try
        {
            // Use the username from inputData
            String username = inputData.getUsername();

            // Fetch threads for the given username
            List<Thread> threads = threadDataAccess.getThreadsByUsername(username);

            if (threads.isEmpty())
            {
                presenter.prepareFailView("No threads found for user: " + username);
            } else
            {
                presenter.prepareSuccessView(new GetThreadsOutputData(threads));
            }
        } catch (Exception e)
        {
            presenter.prepareFailView("Error occurred: " + e.getMessage());
        }
    }

    @Override
    public void switchToChatView(Long threadID)
    {
        presenter.switchToChatView(threadID);
    }

    @Override
    public void switchToAddThreadView()
    {
        presenter.switchToAddThreadView();
    }
}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/use_case/get_threads/GetThreadsOutputBoundary.java =====
package use_case.get_threads;

public interface GetThreadsOutputBoundary
{
    void prepareSuccessView(GetThreadsOutputData getThreadsOutputData);

    void prepareFailView(String errorMessage);

    void switchToChatView(Long threadID);

    void switchToAddThreadView();
}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/use_case/get_threads/GetThreadsInputData.java =====
package use_case.get_threads;

/**
 * Input data for the Get Threads Use Case.
 */
public class GetThreadsInputData
{
    private final String username;

    public GetThreadsInputData(String username)
    {
        this.username = username;
    }

    public String getUsername()
    {
        return username;
    }
}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/use_case/get_threads/GetThreadsInputBoundary.java =====
package use_case.get_threads;

public interface GetThreadsInputBoundary
{

    void execute(GetThreadsInputData inputData);

    void switchToChatView(Long threadID);

    void switchToAddThreadView();
}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/use_case/signup/SignupInputBoundary.java =====
package use_case.signup;

/**
 * Input Boundary for actions which are related to signing up.
 */
// TODO: overwrite with our code
public interface SignupInputBoundary
{
    /**
     * Executes the signup use case.
     *
     * @param signupInputData the input data
     */
    void execute(SignupInputData signupInputData);

    /**
     * Executes the switch to login view use case.
     */
    void switchToLoginView();
}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/use_case/signup/SignupInteractor.java =====
package use_case.signup;

import entity.User;
import entity.UserFactory;

/**
 * The Signup Interactor.
 */
public class SignupInteractor implements SignupInputBoundary
{
    private final SignupUserDataAccessInterface userDataAccessObject;
    private final SignupOutputBoundary userPresenter;
    private final UserFactory userFactory;

    public SignupInteractor(SignupUserDataAccessInterface signupDataAccessInterface,
                            SignupOutputBoundary signupOutputBoundary,
                            UserFactory userFactory)
    {
        this.userDataAccessObject = signupDataAccessInterface;
        this.userPresenter = signupOutputBoundary;
        this.userFactory = userFactory;
    }

    public void execute(SignupInputData signupInputData)
    {
        String username = signupInputData.getUsername();
        String email = signupInputData.getEmail();
        String password = signupInputData.getPassword();
        String repeatPassword = signupInputData.getRepeatPassword();

        System.out.println(username + " " + email + " " + password + " " + repeatPassword);

        // Username validation
        if (username == null || username.trim().isEmpty())
        {
            userPresenter.prepareFailView("Username cannot be empty.");
            return;
        }
        if (!username.matches("^[a-zA-Z0-9_]{3,15}$"))
        {
            userPresenter.prepareFailView("Username must be 3-15 characters and contain only letters, numbers, or underscores.");
            return;
        }

        // Email validation
        if (email == null || email.trim().isEmpty())
        {
            userPresenter.prepareFailView("Email cannot be empty.");
            return;
        }
        if (!isValidEmail(email))
        {
            userPresenter.prepareFailView("Please enter a valid email address.");
            return;
        }

        // Password validation
        if (password == null || password.isEmpty())
        {
            userPresenter.prepareFailView("Password cannot be empty.");
            return;
        }
        if (password.length() < 8)
        {
            userPresenter.prepareFailView("Password must be at least 8 characters long.");
            return;
        }
        if (!password.equals(repeatPassword))
        {
            userPresenter.prepareFailView("Passwords don't match.");
            return;
        }

        final User user = userFactory.create(
                signupInputData.getUsername(),
                signupInputData.getPassword(),
                signupInputData.getEmail()
        );

        try
        {
            // Attempt to save the user via the DAO
            userDataAccessObject.save(user);

            // On success, prepare the success view
            final SignupOutputData signupOutputData = new SignupOutputData(user.getUsername(), false);
            userPresenter.prepareSuccessView(signupOutputData);

        } catch (Exception e)
        {
            // Log the exception (optional)
            e.printStackTrace();

            // Provide a generic error message to the user
            userPresenter.prepareFailView("An error occurred during sign-up. Please try again later.");
        }
    }

    // Helper method to validate email format
    private boolean isValidEmail(String email)
    {
        String emailRegex = "^[\\w-\\.]+@([\\w-]+\\.)+[\\w-]{2,4}$";
        return email.matches(emailRegex);
    }

    @Override
    public void switchToLoginView()
    {
        userPresenter.switchToLoginView();
    }
}



===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/use_case/signup/SignupOutputData.java =====
package use_case.signup;

/**
 * Output Data for the Signup Use Case.
 */
// TODO: overwrite with our code
public class SignupOutputData
{

    private final String username;
    private final boolean useCaseFailed;

    public SignupOutputData(String username, boolean useCaseFailed)
    {
        this.username = username;
        this.useCaseFailed = useCaseFailed;
    }

    public final String getUsername()
    {
        return username;
    }

    public final boolean isUseCaseFailed()
    {
        return useCaseFailed;
    }
}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/use_case/signup/SignupUserDataAccessInterface.java =====
package use_case.signup;

import entity.User;

/**
 * DAO for the Signup Use Case.
 */
// TODO: overwrite with our code
public interface SignupUserDataAccessInterface
{

    /**
     * Checks if the given username exists.
     *
     * @param username the username to look for
     * @return true if a user with the given username exists; false otherwise
     */
    boolean existsByName(String username);

    /**
     * Saves the user.
     *
     * @param user the user to save
     */
    void save(User user) throws Exception;
}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/use_case/signup/SignupOutputBoundary.java =====
package use_case.signup;

/**
 * The output boundary for the Signup Use Case.
 */
// TODO: overwrite with our code
public interface SignupOutputBoundary
{

    /**
     * Prepares the success view for the Signup Use Case.
     *
     * @param outputData the output data
     */
    void prepareSuccessView(SignupOutputData outputData);

    /**
     * Prepares the failure view for the Signup Use Case.
     *
     * @param errorMessage the explanation of the failure
     */
    void prepareFailView(String errorMessage);

    /**
     * Switches to the Login View.
     */
    void switchToLoginView();
}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/use_case/signup/SignupInputData.java =====
package use_case.signup;

/**
 * The Input Data for the Signup Use Case.
 */
// TODO: overwrite with our code
public class SignupInputData
{

    private final String username;
    private final String password;
    private final String repeatPassword;
    private final String email;

    public SignupInputData(String username, String password, String repeatPassword, String email)
    {
        this.username = username;
        this.password = password;
        this.repeatPassword = repeatPassword;
        this.email = email;
    }

    public final String getUsername()
    {
        return username;
    }

    public final String getPassword()
    {
        return password;
    }

    public final String getRepeatPassword()
    {
        return repeatPassword;
    }

    public final String getEmail()
    {
        return email;
    }
}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/use_case/send_message/SendMessageOutputBoundary.java =====
package use_case.send_message;

/**
 * The output boundary for the Send Message Use Case.
 */
public interface SendMessageOutputBoundary
{
    /**
     * Prepares the success view for the Send Message Use Case.
     *
     * @param outputData the output data
     */
    void prepareSuccessView(SendMessageOutputData outputData);

    /**
     * Prepares the failure view for the Send Message Use Case.
     *
     * @param errorMessage the explanation of the failure
     */
    void prepareFailView(String errorMessage);

    /**
     * Switches to Threads View.
     */
    void switchToThreadsView();
}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/use_case/send_message/SendMessageInteractor.java =====
package use_case.send_message;

import java.io.IOException;

import entity.Message;
import entity.MessageFactory;

/**
 * The Send Message Interactor.
 */
public class SendMessageInteractor implements SendMessageInputBoundary
{

    private final SendMessageMessageDataAccessInterface messageDataAccessObject;

    private final SendMessageOutputBoundary sendMessagePresenter;
    private final MessageFactory messageFactory;

    public SendMessageInteractor(SendMessageMessageDataAccessInterface messageDataAccessObject,
                                 MessageFactory messageFactory,
                                 SendMessageOutputBoundary sendMessagePresenter)
    {
        this.sendMessagePresenter = sendMessagePresenter;
        this.messageDataAccessObject = messageDataAccessObject;
        this.messageFactory = messageFactory;
    }

    @Override
    public void execute(SendMessageInputData sendMessageInputData)
    {
        // Check whether the message content is empty or too long.
        if (sendMessageInputData.getContent().isEmpty())
        {
            sendMessagePresenter.prepareFailView("Message field is empty.");
        }
        else if (sendMessageInputData.getContent().length() >= Message.MESSAGE_MAX_LENGTH)
        {
            sendMessagePresenter.prepareFailView(
                    "Message is too long. Must be under " + Message.MESSAGE_MAX_LENGTH + " characters.");
        }
        // Otherwise, create Message object and save it to the database
        else
        {
            // create the message to save
            final Message messageToSave = messageFactory.create(
                    sendMessageInputData.getContent(),
                    sendMessageInputData.getSenderUsername());

            try
            {
                // Save the message object, raise exception is anything server-side fails.
                final Message messageToPresent = messageDataAccessObject.save(messageToSave,
                        sendMessageInputData.getThreadID());

                // Prepare output data object and call the presenter.
                final SendMessageOutputData sendMessageOutputData =
                        new SendMessageOutputData(messageToPresent.getSenderUsername(),
                                messageToPresent.getContent(),
                                messageToPresent.getTimestamp(), false);

                sendMessagePresenter.prepareSuccessView(sendMessageOutputData);
            }
            catch (IOException exception)
            {
                sendMessagePresenter.prepareFailView(exception.getMessage());
            }
            catch (Exception exception)
            {
                sendMessagePresenter.prepareFailView(
                        "An unexpected error occurred: " + exception.getMessage());
            }
        }
    }

    @Override
    public void switchToThreadsView()
    {
        sendMessagePresenter.switchToThreadsView();
    }
}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/use_case/send_message/SendMessageInputData.java =====
package use_case.send_message;

/**
 * The Input Data for the Send Message Use Case.
 */
public final class SendMessageInputData
{

    private final Long threadID;
    private final String content;
    private final String senderUsername;

    public SendMessageInputData(String content, Long threadID, String senderUsername)
    {
        this.threadID = threadID;
        this.content = content;
        this.senderUsername = senderUsername;
    }

    public String getContent()
    {
        return content;
    }

    public Long getThreadID()
    {
        return threadID;
    }

    public String getSenderUsername()
    {
        return senderUsername;
    }
}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/use_case/send_message/SendMessageOutputData.java =====
package use_case.send_message;

/**
 * Output Data for the Send Message Case.
 */
public class SendMessageOutputData
{
    private final String content;
    private final String senderUsername;
    private final boolean useCaseFailed;
    private final String timestamp;

    public SendMessageOutputData(String senderUsername, String content, String timestamp, boolean useCaseFailed)
    {
        this.senderUsername = senderUsername;
        this.useCaseFailed = useCaseFailed;
        this.content = content;
        this.timestamp = timestamp;
    }

    public final String getSenderUsername()
    {
        return senderUsername;
    }

    public final String getContent()
    {
        return content;
    }

    public final String getTimestamp()
    {
        return timestamp;
    }

    public final boolean isUseCaseFailed()
    {
        return useCaseFailed;
    }
}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/use_case/send_message/SendMessageMessageDataAccessInterface.java =====
package use_case.send_message;

import entity.Message;

/**
 * DAO for the Send Message Use Case ; for the Message.
 */
public interface SendMessageMessageDataAccessInterface
{
    /**
     * Saves the sent message and returns a message object with a timestamp from the server.
     *
     * @param message  the sent message to save
     * @param threadID the ID of the thread to save the message within
     * @return a representation of the new message that was created
     */
    Message save(Message message, Long threadID) throws Exception;
}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/use_case/send_message/SendMessageInputBoundary.java =====
package use_case.send_message;

/**
 * Input Boundary for actions which are related to sending a message.
 */
public interface SendMessageInputBoundary
{

    /**
     * Executes the send message use case.
     *
     * @param sendMessageInputData the input data
     */
    void execute(SendMessageInputData sendMessageInputData);

    /**
     * Executes the "switch to ThreadsView" use case.
     */
    void switchToThreadsView();
}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/use_case/logout/LogoutInteractor.java =====
package use_case.logout;

/**
 * The Logout Interactor.
 */
public class LogoutInteractor implements LogoutInputBoundary
{
    private LogoutUserDataAccessInterface userDataAccessObject;
    private LogoutOutputBoundary logoutPresenter;

    public LogoutInteractor(LogoutUserDataAccessInterface userDataAccessInterface,
                            LogoutOutputBoundary logoutOutputBoundary)
    {
        this.userDataAccessObject = userDataAccessInterface;
        this.logoutPresenter = logoutOutputBoundary;
    }

    @Override
    public void execute()
    {
        // * set the username to null in the DAO;
        userDataAccessObject.logout();
        logoutPresenter.prepareSuccessView();

    }
}



===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/use_case/logout/LogoutInputBoundary.java =====
package use_case.logout;

/**
 * Input Boundary for actions which are related to logging in.
 */
public interface LogoutInputBoundary
{

    /**
     * Executes the Logout use case.
     */
    void execute();
}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/use_case/logout/LogoutUserDataAccessInterface.java =====
package use_case.logout;

/**
 * DAO for the Logout Use Case.
 */
public interface LogoutUserDataAccessInterface
{

    /**
     * Logs the user out of the program (deletes their token).
     */
    void logout();
}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/use_case/logout/LogoutOutputBoundary.java =====
package use_case.logout;

/**
 * The output boundary for the Login Use Case.
 */
// TODO: overwrite with our code
public interface LogoutOutputBoundary
{
    /**
     * Prepares the success view for the Login Use Case.
     */
    void prepareSuccessView();

    /**
     * Prepares the failure view for the Login Use Case.
     *
     * @param errorMessage the explanation of the failure
     */
    void prepareFailView(String errorMessage);
}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/use_case/add_thread/AddThreadInputBoundary.java =====
package use_case.add_thread;

/**
 * Input Boundary for actions which are related to sending related a new thread.
 */
public interface AddThreadInputBoundary
{

    /**
     * Executes the add thread use case.
     *
     * @param addThreadInputData the input data
     */
    void execute(AddThreadInputData addThreadInputData);

    /**
     * Executes the "switch to ThreadsView" use case.
     */
    void switchToThreadsView();
}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/use_case/add_thread/AddThreadThreadDataAccessInterface.java =====
package use_case.add_thread;

import entity.Thread;

/**
 * DAO for the Add Thread Use Case ; for the Thread.
 * Contains all necessary methods to create a new thread.
 */
public interface AddThreadThreadDataAccessInterface
{
    /**
     * Saves and the new thread to the server and returns a fully constructed one.
     *
     * @param thread the thread to save
     * @return a representation of the newly created thread as it exists in the server
     */
    Thread save(Thread thread) throws Exception;
}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/use_case/add_thread/AddThreadInteractor.java =====
package use_case.add_thread;

import java.io.IOException;

import entity.Thread;
import entity.ThreadFactory;

/**
 * The Add Thread Interactor.
 */
public class AddThreadInteractor implements AddThreadInputBoundary
{
    private final AddThreadThreadDataAccessInterface threadDataAccessObject;
    private final ThreadFactory threadFactory;
    private final AddThreadOutputBoundary addThreadPresenter;

    public AddThreadInteractor(AddThreadThreadDataAccessInterface threadDataAccessObject,
                               AddThreadOutputBoundary addThreadPresenter,
                               ThreadFactory threadFactory)
    {
        this.threadDataAccessObject = threadDataAccessObject;
        this.addThreadPresenter = addThreadPresenter;
        this.threadFactory = threadFactory;
    }

    @Override
    public void execute(AddThreadInputData addThreadInputData)
    {
        // Check whether the thread name is empty, too long or too short
        if (addThreadInputData.getThreadName().isEmpty())
        {
            addThreadPresenter.prepareFailView("Thread name field is empty.");
        }
        else if (addThreadInputData.getThreadName().length() > Thread.THREAD_NAME_MAX_LENGTH)
        {
            addThreadPresenter.prepareFailView(
                    "Thread name is too long. Must be under "
                            + Thread.THREAD_NAME_MAX_LENGTH + " characters.");
        }
        else if (addThreadInputData.getThreadName().length() < Thread.THREAD_NAME_MIN_LENGTH)
        {
            addThreadPresenter.prepareFailView(
                    "Thread name is too short. Must be at least "
                            + Thread.THREAD_NAME_MIN_LENGTH + " characters.");
        }

        // Check whether the users list is empty or poorly formatted
        else if (addThreadInputData.getUsernameList().isEmpty())
        {
            addThreadPresenter.prepareFailView("List of Users is Empty");
        }
        else if (!userListIsWellFormatted(addThreadInputData.getUsernameList()))
        {
            addThreadPresenter.prepareFailView("List of users is poorly formatted. \n "
                    + "(should be separated by commas and contain no spaces)");
        }
        else
        {
            // complete the username list with the current user's username.
            String userList = createFormattedUserList(addThreadInputData.getUsernameList());

            // create thread object to save
            Thread threadToSave = threadFactory.create(addThreadInputData.getThreadName(), userList);

            // try to save the new thread to the server
            try
            {
                Thread threadToPresent = threadDataAccessObject.save(threadToSave);

                // create output data and fire presenter
                AddThreadOutputData outputData = new AddThreadOutputData(
                        threadToPresent.getName(),
                        threadToPresent.getThreadID()
                );
                addThreadPresenter.prepareSuccessView(outputData,
                        "New thread '" + threadToPresent.getName() + "' has been successfully created.");
            }
            catch (IOException | IllegalAccessException exception)
            {
                addThreadPresenter.prepareFailView(exception.getMessage());

            }
            catch (Exception exception)
            {
                addThreadPresenter.prepareFailView(
                        "An unexpected error occurred: " + exception.getMessage());
            }

        }
    }

    /**
     * Returns true if the given string is well-formatted, according to the regex.
     *
     * @param string string to check
     * @return true if usernameList is well-formatted, false otherwise
     */
    private boolean userListIsWellFormatted(String string)
    {
        String regex = "^ *[a-zA-Z0-9]+( *, *[a-zA-Z0-9]+)* *$";
        return string.matches(regex);
    }

    /**
     * Returns the full list of users in the thread, as a comma-separated String.
     *
     * @param userList the list of users from the input data
     * @return a concatenation of the two that follows the regex
     */
    private String createFormattedUserList(String userList)
    {
        return userList.replaceAll("\\s+", "");
    }

    @Override
    public void switchToThreadsView()
    {
        addThreadPresenter.switchToThreadsView();
    }
}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/use_case/add_thread/AddThreadInputData.java =====
package use_case.add_thread;

/**
 * The Input Data for the Add Thread Use Case.
 */
public final class AddThreadInputData
{

    private final String threadName;
    private final String usernameList;
    private final String currentUsername;

    public AddThreadInputData(String threadName, String usernameList, String currentUsername)
    {
        this.threadName = threadName;
        this.usernameList = usernameList;
        this.currentUsername = currentUsername;
    }

    public String getUsernameList()
    {
        return usernameList;
    }

    public String getThreadName()
    {
        return threadName;
    }

    public String getCurrentUsername()
    {
        return currentUsername;
    }
}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/use_case/add_thread/AddThreadOutputData.java =====
package use_case.add_thread;

/**
 * Output Data for the Add Thread Use Case.
 */
public class AddThreadOutputData
{

    private final String threadName;
    private final Long threadID;

    public AddThreadOutputData(String threadName, Long threadID)
    {
        this.threadName = threadName;
        this.threadID = threadID;
    }

    public final String getThreadName()
    {
        return threadName;
    }

    public final Long getThreadID()
    {
        return threadID;
    }
}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/use_case/add_thread/AddThreadOutputBoundary.java =====
package use_case.add_thread;

/**
 * The output boundary for the Thread Use Case.
 */
public interface AddThreadOutputBoundary
{
    /**
     * Prepares the success view for the Thread Use Case.
     *
     * @param outputData     the output data
     * @param successMessage the message to display on success
     */
    void prepareSuccessView(AddThreadOutputData outputData, String successMessage);

    /**
     * Prepares the failure view for the Thread Use Case.
     *
     * @param errorMessage the explanation of the failure
     */
    void prepareFailView(String errorMessage);

    /**
     * Switches to Threads View.
     */
    void switchToThreadsView();
}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/use_case/chat_refresh/ChatRefreshInputData.java =====
package use_case.chat_refresh;

public class ChatRefreshInputData
{
    private final Long threadID;

    public ChatRefreshInputData(Long threadID)
    {
        this.threadID = threadID;
    }

    public Long getThreadID()
    {
        return threadID;
    }
}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/use_case/chat_refresh/ChatRefreshOutputData.java =====
package use_case.chat_refresh;

import java.util.List;

/**
 * Output data for the Chat Refresh Use Case.
 */
public class ChatRefreshOutputData
{
    private final List<String[]> messages;

    public ChatRefreshOutputData(List<String[]> messages)
    {
        this.messages = messages;
    }

    public List<String[]> getMessages()
    {
        return messages;
    }
}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/use_case/chat_refresh/ChatRefreshThreadDataAccessInterface.java =====
package use_case.chat_refresh;

import entity.Message;

import java.util.List;


public interface ChatRefreshThreadDataAccessInterface
{
    /**
     * Updates the current message thread when the refresh is triggered. If a new message has been sent, it is added to the thread

     */
    /**
     * Updates the current message thread when the refresh is triggered. If a new message has been sent, it is added to the thread
     */

    List<Message> getMessages(Long threadID) throws Exception;
}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/use_case/chat_refresh/ChatRefreshInputBoundary.java =====
package use_case.chat_refresh;

public interface ChatRefreshInputBoundary
{
    /**
     * Exectutes the ChatRefresh Usecase
     */
    void execute(ChatRefreshInputData inputData);
}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/use_case/chat_refresh/ChatRefreshOutputBoundary.java =====
package use_case.chat_refresh;

public interface ChatRefreshOutputBoundary
{
    /**
     * Prepares the success view for the Login Use Case.
     * output data
     */
    void prepareSuccessView(ChatRefreshOutputData outputData);
    void prepareFailView(String errorMessage);
}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/use_case/chat_refresh/ChatRefreshInteractor.java =====
package use_case.chat_refresh;

import entity.Message;

import java.util.ArrayList;
import java.util.List;

public class ChatRefreshInteractor implements ChatRefreshInputBoundary
{
    private final ChatRefreshThreadDataAccessInterface threadDataAccessObject;
    private final ChatRefreshOutputBoundary chatRefreshPresenter;

    public ChatRefreshInteractor(
            ChatRefreshThreadDataAccessInterface threadDataAccessObject,
            ChatRefreshOutputBoundary chatRefreshPresenter)
    {
        this.threadDataAccessObject = threadDataAccessObject;
        this.chatRefreshPresenter = chatRefreshPresenter;
    }

    @Override
    public void execute(ChatRefreshInputData inputData)
    {
        try
        {
            Long threadID = inputData.getThreadID();
            List<Message> messageList = threadDataAccessObject.getMessages(threadID);

            List<String[]> messages = new ArrayList<>();
            for (Message message : messageList)
            {
                String[] lst = {
                        message.getSenderUsername(),
                        message.getContent(),
                        message.getTimestamp()
                };
                messages.add(lst);
            }

            ChatRefreshOutputData outputData = new ChatRefreshOutputData(messages);
            chatRefreshPresenter.prepareSuccessView(outputData);

        } catch (Exception e)
        {
            chatRefreshPresenter.prepareFailView("Error: " + e.getMessage());
        }
    }
}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/use_case/login/LoginInputData.java =====
package use_case.login;

/**
 * The Input Data for the Login Use Case.
 */
public final class LoginInputData
{

    private final String usernameOrEmail;
    private final String password;

    public LoginInputData(String usernameOrEmail, String password)
    {
        this.usernameOrEmail = usernameOrEmail;
        this.password = password;
    }

    public String getUsernameOrEmail()
    {
        return usernameOrEmail;
    }

    public String getPassword()
    {
        return password;
    }

}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/use_case/login/LoginUserDataAccessInterface.java =====
package use_case.login;

import entity.User;
import org.json.JSONObject;

/**
 * DAO for the Login Use Case.
 */
// TODO: overwrite with our code
public interface LoginUserDataAccessInterface
{

    /**
     * Checks if the given username exists.
     *
     * @param username the username to look for
     * @return true if a user with the given username exists; false otherwise
     */
    boolean existsByName(String username);

    /**
     * Checks if the given user exists.
     *
     * @param username the email of the user to look for
     * @param password the password of the user to look for
     * @return JSONObject containing the authentication token, username, and any messages or errors.
     */
    JSONObject validateCredentials(String username, String password);

    /**
     * Saves the user.
     *
     * @param user the user to save
     */
    void save(User user) throws Exception;

    /**
     * Returns the user with the given username.
     *
     * @param username the username to look up
     * @return the user with the given username
     */
    User get(String username);

    /**
     * Returns the username of the curren user of the application.
     *
     * @return the username of the current user; null indicates that no one is logged into the application.
     */
    String getCurrentUsername();

    /**
     * Sets the username indicating who is the current user of the application.
     *
     * @param username the new current username; null to indicate that no one is currently logged into the application.
     */
    void setCurrentUsername(String username);
}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/use_case/login/LoginInputBoundary.java =====
package use_case.login;

/**
 * Input Boundary for actions which are related to logging in.
 */
public interface LoginInputBoundary
{

    /**
     * Executes the login use case.
     *
     * @param loginInputData the input data
     */
    void execute(LoginInputData loginInputData);

    /**
     * Executes the switch to sign up view use case.
     */
    void switchToSignUpView();
}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/use_case/login/LoginInteractor.java =====
package use_case.login;

import org.json.JSONObject;

/**
 * The Login Interactor.
 */
// TODO: overwrite with our code
public class LoginInteractor implements LoginInputBoundary
{
    private final LoginUserDataAccessInterface userDataAccessObject;
    private final LoginOutputBoundary loginPresenter;

    public LoginInteractor(LoginUserDataAccessInterface userDataAccessInterface,
                           LoginOutputBoundary loginOutputBoundary)
    {
        this.userDataAccessObject = userDataAccessInterface;
        this.loginPresenter = loginOutputBoundary;
    }

    @Override
    public void execute(LoginInputData loginInputData)
    {
        final String usernameOrEmail = loginInputData.getUsernameOrEmail();
        final String password = loginInputData.getPassword();

        try
        {
            JSONObject response = userDataAccessObject.validateCredentials(usernameOrEmail, password);
            if (response.has("authToken"))
            {
                String username = response.optString("username");
                String message = response.optString("message");
                LoginOutputData loginOutputData = new LoginOutputData(username, message, false);
                loginPresenter.prepareSuccessView(loginOutputData);
            } else if (response.has("error"))
            {
                String errorMessage = response.optString("message");
                loginPresenter.prepareFailView(errorMessage);
            }
            else{
                loginPresenter.prepareFailView("Login failed");
            }
        } catch (Exception e)
        {
            loginPresenter.prepareFailView("An error occurred during login: " + e.getMessage());
        }
    }

    @Override
    public void switchToSignUpView()
    {
        loginPresenter.switchToSignUpView();
    }
}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/use_case/login/LoginOutputData.java =====
package use_case.login;

/**
 * Output Data for the Login Use Case.
 */
// TODO: overwrite with our code
public class LoginOutputData
{

    private final String username;
    private final String message;
    private final boolean useCaseFailed;

    public LoginOutputData(String username, String message, boolean useCaseFailed)
    {
        this.username = username;
        this.message = message;
        this.useCaseFailed = useCaseFailed;
    }

    public final String getUsername()
    {
        return username;
    }

    public final String getMessage()
    {
        return message;
    }

}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/use_case/login/LoginOutputBoundary.java =====
package use_case.login;

/**
 * The output boundary for the Login Use Case.
 */
// TODO: overwrite with our code
public interface LoginOutputBoundary
{
    /**
     * Prepares the success view for the Login Use Case.
     *
     * @param outputData the output data
     */
    void prepareSuccessView(LoginOutputData outputData);

    /**
     * Prepares the failure view for the Login Use Case.
     *
     * @param errorMessage the explanation of the failure
     */
    void prepareFailView(String errorMessage);

    /**
     * Switches to the SignUp View.
     */
    void switchToSignUpView();
}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/view/ViewManager.java =====
package view;

import interface_adapter.ViewManagerModel;

import javax.swing.*;
import java.awt.*;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;

/**
 * The View Manager for the program. It listens for property change events
 * in the ViewManagerModel and updates which View should be visible.
 */
// TODO: overwrite with our code
public class ViewManager implements PropertyChangeListener
{
    private final CardLayout cardLayout;
    private final JPanel views;
    private final ViewManagerModel viewManagerModel;

    public ViewManager(JPanel views, CardLayout cardLayout, ViewManagerModel viewManagerModel)
    {
        this.views = views;
        this.cardLayout = cardLayout;
        this.viewManagerModel = viewManagerModel;
        this.viewManagerModel.addPropertyChangeListener(this);
    }

    @Override
    public void propertyChange(PropertyChangeEvent evt)
    {
        if (evt.getPropertyName().equals("state"))
        {
            final String viewModelName = (String) evt.getNewValue();
            cardLayout.show(views, viewModelName);
        }
    }
}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/view/SignupView.java =====
package view;

import interface_adapter.signup.SignupController;
import interface_adapter.signup.SignupState;
import interface_adapter.signup.SignupViewModel;
import view.custom_panels.LabelTextPanel;

import javax.swing.*;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;

/**
 * The View for the Signup Use Case.
 */
public class SignupView extends JPanel implements ActionListener, PropertyChangeListener
{
    private final String viewName = "sign up";

    private final SignupViewModel signupViewModel;

    private final JTextField usernameInputField = new JTextField(15);
    private final JTextField emailInputField = new JTextField(15);
    private final JPasswordField passwordInputField = new JPasswordField(15);
    private final JPasswordField repeatPasswordInputField = new JPasswordField(15);
    private final JButton signUp;
    private final JButton cancel;
    private final JButton toLogin;
    private SignupController signupController;

    // Constructor
    public SignupView(SignupViewModel signupViewModel)
    {
        this.signupViewModel = signupViewModel;

        // Initialize the Page Title
        final JLabel title = new JLabel(SignupViewModel.TITLE_LABEL);
        title.setAlignmentX(Component.CENTER_ALIGNMENT);

        // Initialize the User Information ( text Entries)
        final LabelTextPanel usernameInfo = new LabelTextPanel(
                new JLabel(SignupViewModel.USERNAME_LABEL), usernameInputField);
        final LabelTextPanel emailInfo = new LabelTextPanel(
                new JLabel(SignupViewModel.EMAIL_LABEL), emailInputField);
        final LabelTextPanel passwordInfo = new LabelTextPanel(
                new JLabel(SignupViewModel.PASSWORD_LABEL), passwordInputField);
        final LabelTextPanel repeatPasswordInfo = new LabelTextPanel(
                new JLabel(SignupViewModel.REPEAT_PASSWORD_LABEL), repeatPasswordInputField);

        // Initialize Buttons
        final JPanel buttons = new JPanel();
        toLogin = new JButton(SignupViewModel.TO_LOGIN_BUTTON_LABEL);
        buttons.add(toLogin);
        signUp = new JButton(SignupViewModel.SIGNUP_BUTTON_LABEL);
        buttons.add(signUp);
        cancel = new JButton(SignupViewModel.CANCEL_BUTTON_LABEL);
        buttons.add(cancel);

        // Add Action listeners for the buttons
        signUp.addActionListener(
                new ActionListener()
                {
                    public void actionPerformed(ActionEvent evt)
                    {
                        if (evt.getSource().equals(signUp))
                        {
                            final SignupState currentState = signupViewModel.getState();
                            // Call the signup controller with username, email, password, and repeatPassword
                            signupController.execute(
                                    currentState.getUsername(),
                                    currentState.getEmail(),
                                    currentState.getPassword(),
                                    currentState.getRepeatPassword()
                            );
                        }
                    }
                }
        );

        toLogin.addActionListener(
                new ActionListener()
                {
                    public void actionPerformed(ActionEvent evt)
                    {
                        signupController.switchToLoginView();
                    }
                }
        );

        cancel.addActionListener(this);

        // Add listeners for the text entries
        addUsernameListener();
        addEmailListener();
        addPasswordListener();
        addRepeatPasswordListener();

        // Set Up the layout for the UI
        this.setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));

        this.add(title);
        this.add(usernameInfo);
        this.add(emailInfo);
        this.add(passwordInfo);
        this.add(repeatPasswordInfo);
        this.add(buttons);

        // Add margin of 40 pixels on all sides
        this.setBorder(BorderFactory.createEmptyBorder(40, 40, 40, 40));
    }

    /**
     * Listens to the changes in teh username field and updates the current state.
     */
    private void addUsernameListener()
    {
        usernameInputField.getDocument().addDocumentListener(new DocumentListener()
        {

            private void documentListenerHelper()
            {
                final SignupState currentState = signupViewModel.getState();
                currentState.setUsername(usernameInputField.getText());
                signupViewModel.setState(currentState);
            }

            @Override
            public void insertUpdate(DocumentEvent e)
            {
                // Change if a new value is added
                documentListenerHelper();
            }

            @Override
            public void removeUpdate(DocumentEvent e)
            {
                // Change if a value is removed
                documentListenerHelper();
            }

            @Override
            public void changedUpdate(DocumentEvent e)
            {
                // Change if a value is changed
                documentListenerHelper();
            }
        });
    }

    /**
     * Listens to the changes in teh username field and updates the current state.
     */
    private void addEmailListener()
    {
        emailInputField.getDocument().addDocumentListener(new DocumentListener()
        {

            private void documentListenerHelper()
            {
                final SignupState currentState = signupViewModel.getState();
                currentState.setEmail(emailInputField.getText());
                signupViewModel.setState(currentState);
            }

            @Override
            public void insertUpdate(DocumentEvent e)
            {
                // Change if a new value is added
                documentListenerHelper();
            }

            @Override
            public void removeUpdate(DocumentEvent e)
            {
                // Change if a value is removed
                documentListenerHelper();
            }

            @Override
            public void changedUpdate(DocumentEvent e)
            {
                // Change if a value is changed
                documentListenerHelper();
            }
        });
    }

    /**
     * Listens to the Password field and if a change is made updates the values in sign Up state.
     */
    private void addPasswordListener()
    {
        passwordInputField.getDocument().addDocumentListener(new DocumentListener()
        {

            private void documentListenerHelper()
            {
                final SignupState currentState = signupViewModel.getState();
                currentState.setPassword(new String(passwordInputField.getPassword()));
                signupViewModel.setState(currentState);
            }

            @Override
            public void insertUpdate(DocumentEvent e)
            {
                // Change if a new value is added
                documentListenerHelper();
            }

            @Override
            public void removeUpdate(DocumentEvent e)
            {
                // Change if a value is removed
                documentListenerHelper();
            }

            @Override
            public void changedUpdate(DocumentEvent e)
            {
                // Change if a value is changed
                documentListenerHelper();
            }
        });
    }

    /**
     * Listens for updates in the repeat password field, and then updates the values of signupViewModel.
     */
    private void addRepeatPasswordListener()
    {
        repeatPasswordInputField.getDocument().addDocumentListener(new DocumentListener()
        {

            private void documentListenerHelper()
            {
                final SignupState currentState = signupViewModel.getState();
                currentState.setRepeatPassword(new String(repeatPasswordInputField.getPassword()));
                signupViewModel.setState(currentState);
            }

            @Override
            public void insertUpdate(DocumentEvent e)
            {
                // Change if a new value is added
                documentListenerHelper();
            }

            @Override
            public void removeUpdate(DocumentEvent e)
            {
                // Change if a value is removed
                documentListenerHelper();
            }

            @Override
            public void changedUpdate(DocumentEvent e)
            {
                // Change if a value is changed
                documentListenerHelper();
            }
        });
    }

    @Override
    public void actionPerformed(ActionEvent actionEvent)
    {
        if (actionEvent.getSource() == cancel)
        {
            // Clear all input fields
            usernameInputField.setText("");
            emailInputField.setText("");
            passwordInputField.setText("");
            repeatPasswordInputField.setText("");
        }
    }

    @Override
    public void propertyChange(PropertyChangeEvent evt)
    {
        final SignupState state = (SignupState) evt.getNewValue();
        if (state.getUsernameError() != null)
        {
            JOptionPane.showMessageDialog(this, state.getUsernameError());
        }
    }

    public final String getViewName()
    {
        return viewName;
    }

    public final void setSignupController(SignupController controller)
    {
        this.signupController = controller;
    }
}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/view/LoginView.java =====
package view;

import interface_adapter.login.LoginController;
import interface_adapter.login.LoginState;
import interface_adapter.login.LoginViewModel;
import view.custom_panels.LabelTextPanel;

import javax.swing.*;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;

/**
 * The View for when the user is logging into the program.
 */
public class LoginView extends JPanel implements ActionListener, PropertyChangeListener
{

    private final String viewName = "log in";
    private final LoginViewModel loginViewModel;

    private final JTextField usernameInputField = new JTextField(15);
    private final JLabel usernameErrorField = new JLabel();

    private final JPasswordField passwordInputField = new JPasswordField(15);

    private final JButton logIn;
    private final JButton cancel;
    private LoginController loginController;

    // Constructor
    public LoginView(LoginViewModel loginViewModel)
    {

        // Initialize the Page Title
        this.loginViewModel = loginViewModel;
        this.loginViewModel.addPropertyChangeListener(this);

        final JLabel title = new JLabel("Login Screen");
        title.setAlignmentX(Component.CENTER_ALIGNMENT);

        usernameErrorField.setPreferredSize(new Dimension(300, 20));
        usernameErrorField.setMaximumSize(new Dimension(300, 20));
        usernameErrorField.setAlignmentX(Component.CENTER_ALIGNMENT);

        final LabelTextPanel usernameInfo = new LabelTextPanel(
                new JLabel("Username"), usernameInputField);
        final LabelTextPanel passwordInfo = new LabelTextPanel(
                new JLabel("Password"), passwordInputField);

        final JPanel buttons = new JPanel();
        logIn = new JButton("log in");
        buttons.add(logIn);
        cancel = new JButton("cancel");
        buttons.add(cancel);

        logIn.addActionListener(
                new ActionListener() {
                    public void actionPerformed(ActionEvent evt) {
                        if (evt.getSource().equals(logIn)) {
                            String username = usernameInputField.getText().trim();
                            String password = new String(passwordInputField.getPassword()).trim();

                            if (!username.isEmpty() && !password.isEmpty()) {
                                final LoginState currentState = loginViewModel.getState();
                                loginController.execute(
                                        currentState.getUsernameOrEmail(),
                                        currentState.getPassword()
                                );
                            } else {
                                usernameErrorField.setText("Username and password must not be empty");
                            }
                        }
                    }
                }
        );

        cancel.addActionListener(
                new ActionListener()
                {
                    public void actionPerformed(ActionEvent evt)
                    {
                        if (evt.getSource().equals(cancel))
                        {
                            final LoginState currentState = loginViewModel.getState();
                            currentState.setUsernameOrEmail("");
                            currentState.setPassword("");
                            loginViewModel.setState(currentState);
                            loginViewModel.firePropertyChanged();
                            loginController.switchToSignUpView();
                            usernameErrorField.setText("");
                        }
                    }
                }
        );

        usernameInputField.getDocument().addDocumentListener(new DocumentListener()
        {

            private void documentListenerHelper()
            {
                final LoginState currentState = loginViewModel.getState();
                currentState.setUsernameOrEmail(usernameInputField.getText());
                loginViewModel.setState(currentState);
            }

            @Override
            public void insertUpdate(DocumentEvent e)
            {
                documentListenerHelper();
            }

            @Override
            public void removeUpdate(DocumentEvent e)
            {
                documentListenerHelper();
            }

            @Override
            public void changedUpdate(DocumentEvent e)
            {
                documentListenerHelper();
            }
        });

        this.setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));

        passwordInputField.getDocument().addDocumentListener(new DocumentListener()
        {

            private void documentListenerHelper()
            {
                final LoginState currentState = loginViewModel.getState();
                currentState.setPassword(new String(passwordInputField.getPassword()));
                loginViewModel.setState(currentState);
            }

            @Override
            public void insertUpdate(DocumentEvent e)
            {
                documentListenerHelper();
            }

            @Override
            public void removeUpdate(DocumentEvent e)
            {
                documentListenerHelper();
            }

            @Override
            public void changedUpdate(DocumentEvent e)
            {
                documentListenerHelper();
            }
        });

        this.add(title);
        this.add(usernameInfo);
        this.add(usernameErrorField);
        this.add(passwordInfo);
        this.add(buttons);

        // Add margin of 40 pixels on all sides
        this.setBorder(BorderFactory.createEmptyBorder(40, 40, 40, 40));
    }

    /**
     * React to a button click that results in evt.
     *
     * @param evt the ActionEvent to react to
     */
    public void actionPerformed(ActionEvent evt)
    {
        System.out.println("Click " + evt.getActionCommand());
    }

    @Override
    public void propertyChange(PropertyChangeEvent evt)
    {
        final LoginState state = (LoginState) evt.getNewValue();
        setFields(state);
        usernameErrorField.setText(state.getLoginError());
    }

    private void setFields(LoginState state)
    {
        usernameInputField.setText(state.getUsernameOrEmail());
        passwordInputField.setText(state.getPassword());
    }

    public final String getViewName()
    {
        return viewName;
    }

    public final void setLoginController(LoginController loginController)
    {
        this.loginController = loginController;
    }
}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/view/custom_panels/MessageDisplayPanel.java =====
package view.custom_panels;

import java.awt.*;
import java.util.List;

import javax.swing.*;

import interface_adapter.send_message.ChatViewModel;

/**
 * A scrollable panel displaying a list of LabelLabelPanels.
 */
public class MessageDisplayPanel extends JPanel
{
    private final JPanel boxPanel = new JPanel();

    public MessageDisplayPanel(List<MessagePanel> messagePanels)
    {
        // Set the layout of boxPanel to BoxLayout for vertical stacking
        boxPanel.setLayout(new BoxLayout(boxPanel, BoxLayout.Y_AXIS));

        // Add each message panel to the box panel
        for (MessagePanel messagePanel : messagePanels)
        {
            JPanel wrapperPanel = new JPanel(new FlowLayout(
                    messagePanel.getAlignmentX() == Component.RIGHT_ALIGNMENT ? FlowLayout.RIGHT : FlowLayout.LEFT));
            wrapperPanel.add(messagePanel);
            wrapperPanel.setOpaque(false);
            boxPanel.add(wrapperPanel);
            boxPanel.add(Box.createVerticalStrut(ChatViewModel.MESSAGE_SPACING));
        }

        // Create a JScrollPane to make the box panel scrollable
        JScrollPane scrollPane = new JScrollPane(boxPanel);
        scrollPane.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);
        scrollPane.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);

        // Create a bordered panel to contain the scroll pane
        JPanel borderedPanel = new JPanel(new BorderLayout());
        borderedPanel.setBorder(BorderFactory.createLineBorder(Color.BLACK));
        borderedPanel.add(scrollPane, BorderLayout.CENTER);

        // Set the layout of the main panel to BorderLayout and add the bordered panel
        this.setLayout(new BorderLayout());
        this.add(borderedPanel, BorderLayout.CENTER);
    }

    /**
     * Updates the MessageDisplayPanel with a new list of message panels.
     *
     * @param updatedMessagePanels the updated list of message panels.
     */
    public void updateMessagePanels(List<MessagePanel> updatedMessagePanels)
    {
        boxPanel.removeAll();
        for (MessagePanel messagePanel : updatedMessagePanels)
        {
            JPanel wrapperPanel = new JPanel(new FlowLayout(
                    messagePanel.getAlignmentX() == Component.RIGHT_ALIGNMENT ? FlowLayout.RIGHT : FlowLayout.LEFT));
            wrapperPanel.add(messagePanel);
            wrapperPanel.setOpaque(false);
            boxPanel.add(wrapperPanel);
            boxPanel.add(Box.createVerticalStrut(10));
        }
        boxPanel.revalidate();
        boxPanel.repaint();
    }
}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/view/custom_panels/ButtonLabelButtonButtonPanel.java =====
package view.custom_panels;

import javax.swing.*;

/**
 * A panel containing a button, then a text field, then 2 more buttons, in that order.
 */
public class ButtonLabelButtonButtonPanel extends JPanel
{
    public ButtonLabelButtonButtonPanel(JButton button1, JTextField textField, JButton button2, JButton button3)
    {
        this.add(button1);
        this.add(textField);
        this.add(button2);
        this.add(button3);
    }
}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/view/custom_panels/LabelTextPanel.java =====
package view.custom_panels;

import javax.swing.*;

/**
 * A panel containing a label and a text field.
 */
public class LabelTextPanel extends JPanel
{
    public LabelTextPanel(JLabel label, JTextField textField)
    {
        this.add(label);
        this.add(textField);
    }
}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/view/custom_panels/MessagePanel.java =====
package view.custom_panels;

import interface_adapter.send_message.ChatViewModel;

import javax.swing.*;
import java.awt.*;

/**
 * A panel representing a single message in the ChatView.
 */
public class MessagePanel extends JPanel
{

    public MessagePanel(String sender, String content, String timestamp, boolean isSentByUser)
    {
        // Set panel layout to BoxLayout for vertical stacking of labels
        this.setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));

        // Create labels for sender, content, and timestamp
        JLabel senderLabel = new JLabel(sender);
        senderLabel.setFont(new Font(
                ChatViewModel.MESSAGE_FONT.getName(),
                Font.BOLD,
                ChatViewModel.FONT_SIZE_MESSAGE_SENDER_USERNAME_LABEL));

        JLabel contentLabel = new JLabel("<html><p style=\"width: 200px;\">" + content + "</p></html>");
        contentLabel.setFont(new Font(ChatViewModel.MESSAGE_FONT.getName(),
                ChatViewModel.MESSAGE_FONT.getStyle(),
                ChatViewModel.FONT_SIZE_MESSAGE_CONTENT_LABEL));

        JLabel timestampLabel = new JLabel(timestamp);
        timestampLabel.setFont(new Font(ChatViewModel.MESSAGE_FONT.getName(),
                Font.ITALIC,
                ChatViewModel.FONT_SIZE_MESSAGE_TIMESTAMP_LABEL));

        // Align the panel to the right for sent messages, left for received messages
        if (isSentByUser)
        {
            this.setAlignmentX(Component.RIGHT_ALIGNMENT);
            this.setBackground(new Color(
                    ChatViewModel.LIGHT_BLUE_RGB[0],
                    ChatViewModel.LIGHT_BLUE_RGB[1],
                    ChatViewModel.LIGHT_BLUE_RGB[2]));
        } else
        {
            this.setAlignmentX(Component.LEFT_ALIGNMENT);
            this.setBackground(new Color(
                    ChatViewModel.LIGHT_GREY_RGB[0],
                    ChatViewModel.LIGHT_GREY_RGB[1],
                    ChatViewModel.LIGHT_GREY_RGB[2]));
        }

        // Add padding to the panel for better spacing
        this.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));

        // Add the labels to the panel
        this.add(senderLabel);
        this.add(contentLabel);
        this.add(timestampLabel);

        // Make the panel opaque to apply the background color
        this.setOpaque(true);
    }
}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/view/custom_panels/ButtonLabelPanel.java =====
package view.custom_panels;

import javax.swing.*;
import javax.swing.border.Border;
import java.awt.*;
import java.awt.event.ActionListener;

/**
 * A panel containing a label and a button, styled and aligned properly.
 */
public class ButtonLabelPanel extends JPanel
{
    private final JButton button = new JButton("view");
    private final JLabel label;

    public ButtonLabelPanel(JLabel label)
    {
        this.label = label;

        // Set layout to GridBagLayout for precise control
        setLayout(new GridBagLayout());
        GridBagConstraints gbc = new GridBagConstraints();

        // Configure label constraints
        gbc.gridx = 0;
        gbc.gridy = 0;
        gbc.weightx = 1.0; // Take up remaining horizontal space
        gbc.anchor = GridBagConstraints.WEST;
        gbc.fill = GridBagConstraints.HORIZONTAL;
        this.add(label, gbc);

        // Configure button constraints
        gbc.gridx = 1;
        gbc.weightx = 0.0; // Do not take extra space
        gbc.anchor = GridBagConstraints.EAST;
        gbc.fill = GridBagConstraints.NONE;
        this.add(button, gbc);

        // Define margins and padding
        int panelTopMargin = 5;
        int panelLeftRightMargin = 10; // Left and right margins
        int panelBottomMargin = 5;

        int padding = 10; // Adjust padding to make the box taller and content padded

        // Create the borders
        Border margins = BorderFactory.createEmptyBorder(
                panelTopMargin, panelLeftRightMargin, panelBottomMargin, panelLeftRightMargin);
        Border lineWithPadding = BorderFactory.createCompoundBorder(
                BorderFactory.createLineBorder(Color.BLACK),
                BorderFactory.createEmptyBorder(padding, padding, padding, padding)
        );

        // Set the panel's border to include margins, line border, and padding
        this.setBorder(BorderFactory.createCompoundBorder(margins, lineWithPadding));

        // Add left margin to the label (adjustable)
        int labelLeftMargin = 5; // Adjust this value as needed
        label.setBorder(BorderFactory.createEmptyBorder(0, labelLeftMargin, 0, 0));
    }

    /**
     * Initializes an ActionListener for the button in this panel.
     *
     * @param listener the ActionListener for this button.
     */
    public void setActionListener(ActionListener listener)
    {
        // Remove any existing listeners to prevent duplicates
        for (ActionListener al : button.getActionListeners())
        {
            button.removeActionListener(al);
        }
        button.addActionListener(listener);
    }

    /**
     * Returns the text content of the label.
     *
     * @return the contents of the label.
     */
    public String getLabelContent()
    {
        return label.getText();
    }
}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/view/custom_panels/ThreadsPane.java =====
package view.custom_panels;

import javax.swing.*;
import java.awt.*;
import java.util.ArrayList;
import java.util.List;

/**
 * This creates a component JPanel which is a list of all the threads and their buttons.
 */
public class ThreadsPane extends JScrollPane
{

    private final List<ButtonLabelPanel> buttonLabels = new ArrayList<>();

    public ThreadsPane(String[] threadNames)
    {
        JPanel listPanel = new JPanel();
        listPanel.setLayout(new GridBagLayout());
        GridBagConstraints gbc = new GridBagConstraints();

        // Set common constraints
        gbc.gridx = 0;
        gbc.gridy = GridBagConstraints.RELATIVE;
        gbc.weightx = 1.0;
        gbc.fill = GridBagConstraints.HORIZONTAL;
        gbc.anchor = GridBagConstraints.NORTHWEST;

        int verticalSpacing = 0; // No extra spacing needed due to margins in ButtonLabelPanel

        if (threadNames.length == 0)
        {
            // Display message when no threads are available
            JLabel noThreadsLabel = new JLabel("There are currently no threads.");
            listPanel.add(noThreadsLabel, gbc);
        } else
        {
            // Add each thread as a panel
            for (String threadName : threadNames)
            {
                ButtonLabelPanel panel = new ButtonLabelPanel(new JLabel(threadName));
                buttonLabels.add(panel);

                // Set insets for spacing between panels (if additional spacing is needed)
                gbc.insets = new Insets(0, 0, verticalSpacing, 0);

                listPanel.add(panel, gbc);
            }
        }

        // Add filler to keep components at the top
        gbc.weighty = 1.0;
        listPanel.add(Box.createVerticalGlue(), gbc);

        this.setViewportView(listPanel);
        this.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED);
        this.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
    }

    public final List<ButtonLabelPanel> getButtonLabels()
    {
        return buttonLabels;
    }

    /**
     * Updates the thread pane with an updated list of thread names.
     *
     * @param updatedThreadNames the updated list of thread names.
     */
    public void updateThreadPanel(String[] updatedThreadNames)
    {
        JPanel listPanel = (JPanel) this.getViewport().getView();
        listPanel.removeAll();
        buttonLabels.clear();

        GridBagConstraints gbc = new GridBagConstraints();
        gbc.gridx = 0;
        gbc.gridy = GridBagConstraints.RELATIVE;
        gbc.weightx = 1.0;
        gbc.fill = GridBagConstraints.HORIZONTAL;
        gbc.anchor = GridBagConstraints.NORTHWEST;

        int verticalSpacing = 0; // No extra spacing needed due to margins in ButtonLabelPanel

        if (updatedThreadNames.length == 0)
        {
            // Display message when no threads are available
            JLabel noThreadsLabel = new JLabel("There are currently no threads.");
            listPanel.add(noThreadsLabel, gbc);
        } else
        {
            // Add each thread as a panel
            for (String threadName : updatedThreadNames)
            {
                ButtonLabelPanel panel = new ButtonLabelPanel(new JLabel(threadName));
                buttonLabels.add(panel);

                // Set insets for spacing between panels (if additional spacing is needed)
                gbc.insets = new Insets(0, 0, verticalSpacing, 0);

                listPanel.add(panel, gbc);
            }
        }

        // Add filler to keep components at the top
        gbc.weighty = 1.0;
        listPanel.add(Box.createVerticalGlue(), gbc);

        // Refresh the UI
        listPanel.revalidate();
        listPanel.repaint();
    }

    /**
     * Clears the entire threads pane of its data.
     */
    public void resetPane()
    {
        JPanel listPanel = (JPanel) this.getViewport().getView();
        listPanel.removeAll();
        buttonLabels.clear(); // Clear the list of button labels
        listPanel.revalidate();
        listPanel.repaint();
    }
}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/view/ChatView.java =====
package view;

import interface_adapter.chat_refresh.ChatRefreshController;
import interface_adapter.send_message.ChatState;
import interface_adapter.send_message.ChatViewModel;
import interface_adapter.send_message.SendMessageController;
import view.custom_panels.ButtonLabelButtonButtonPanel;
import view.custom_panels.MessageDisplayPanel;
import view.custom_panels.MessagePanel;

import javax.swing.*;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.util.ArrayList;
import java.util.List;

/**
 * The View for when the user is connected with a single Thread (i.e: a Chat).
 */
public class ChatView extends JPanel implements ActionListener, PropertyChangeListener
{
    private final String viewName = "chat";
    private final ChatViewModel chatViewModel;

    private final MessageDisplayPanel messageDisplay;

    private final JButton toThreads;
    private final JTextField messageInputField = new JTextField(15);
    private final JButton send;
    private final JButton refresh;

    private ChatRefreshController chatRefreshController;
    private SendMessageController sendMessageController;

    // == CONSTRUCTOR ==
    public ChatView(ChatViewModel chatViewModel)
    {
        this.chatViewModel = chatViewModel;
        this.chatViewModel.addPropertyChangeListener(this);

        // Initialize the Page Title to be the name of the Thread it represents.
        final JLabel title = new JLabel(chatViewModel.getState().getCurrentThreadName());
        title.setAlignmentX(Component.CENTER_ALIGNMENT);

        // Initialize the Message View (the Scrollable JList containing all the message Labels)
        messageDisplay = new MessageDisplayPanel(getMessagePanels());

        // Initialize the Text Entry and Buttons
        this.toThreads = new JButton(ChatViewModel.RETURN_BUTTON_LABEL);
        this.send = new JButton(ChatViewModel.SEND_BUTTON_LABEL);
        this.refresh = new JButton(ChatViewModel.REFRESH_BUTTON_LABEL);

        final ButtonLabelButtonButtonPanel bottom = new ButtonLabelButtonButtonPanel(
                toThreads,
                messageInputField,
                send,
                refresh);

        // Add Action Listener for the send button
        send.addActionListener(
                new ActionListener()
                {
                    public void actionPerformed(ActionEvent evt)
                    {
                        final ChatState currentState = chatViewModel.getState();
                        sendMessageController.execute(
                                currentState.getMessageInput(),
                                currentState.getCurrentThreadID(),
                                currentState.getCurrentUsername());
                    }
                });

        // Add Action Listener for the toThreads button
        toThreads.addActionListener(
                new ActionListener()
                {
                    public void actionPerformed(ActionEvent evt)
                    {
                        sendMessageController.switchToThreadsView();
                    }
                }
        );

        // Add Action Listener for the refresh button
        // Set up the refresh button
        refresh.addActionListener(new ActionListener()
        {
            public void actionPerformed(ActionEvent evt)
            {
                ChatState currentState = chatViewModel.getState();
                chatRefreshController.execute(currentState.getCurrentThreadID());
            }
        });

        // Add listener for the text entry (actual code in helper methods below)
        addTextEntryListener();

        // Set Up the layout for the UI
        this.setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
        this.add(title);
        this.add(messageDisplay);
        this.add(bottom);
        this.setBorder(BorderFactory.createEmptyBorder(
                ChatViewModel.BORDER_DIMENSIONS,
                ChatViewModel.BORDER_DIMENSIONS,
                ChatViewModel.BORDER_DIMENSIONS,
                ChatViewModel.BORDER_DIMENSIONS));
    }

    public void setChatRefreshController(ChatRefreshController chatRefreshController)
    {
        this.chatRefreshController = chatRefreshController;
    }

    /**
     * Listens for changes in the message input field and updates ChatViewState.
     */
    private void addTextEntryListener()
    {
        messageInputField.getDocument().addDocumentListener(new DocumentListener()
        {

            private void documentListenerHelper()
            {
                final ChatState currentState = chatViewModel.getState();
                currentState.setMessageInput(messageInputField.getText());
                chatViewModel.setState(currentState);
            }

            @Override
            public void insertUpdate(DocumentEvent e)
            {
                // Change if a new value is added
                documentListenerHelper();
            }

            @Override
            public void removeUpdate(DocumentEvent e)
            {
                // Change if a value is removed
                documentListenerHelper();
            }

            @Override
            public void changedUpdate(DocumentEvent e)
            {
                // Change if a value is changed
                documentListenerHelper();
            }
        });
    }

    @Override
    public void propertyChange(PropertyChangeEvent evt)
    {
        String propertyName = evt.getPropertyName();
        if ("full_message_update".equals(propertyName))
        {
            messageDisplay.updateMessagePanels(getMessagePanels());
        }
        if ("message_update".equals(propertyName))
        {
            final ChatState state = (ChatState) evt.getNewValue();
            messageInputField.setText(state.getMessageInput());
            messageDisplay.updateMessagePanels(getMessagePanels());
        }
        else
        {
            // Handle other property changes
            final ChatState state = (ChatState) evt.getNewValue();
            if (state.getSendMessageError() != null)
            {
                JOptionPane.showMessageDialog(this, state.getSendMessageError());
            }
            // Update text field when state changes
            messageInputField.setText(state.getMessageInput());
        }
    }

    @Override
    public void actionPerformed(ActionEvent evt)
    {
        System.out.println("Click " + evt.getActionCommand());
    }

    public final String getViewName()
    {
        return viewName;
    }

    public final void setSendMessageController(SendMessageController controller)
    {
        this.sendMessageController = controller;
    }

    public List<MessagePanel> getMessagePanels()
    {
        List<MessagePanel> result = new ArrayList<>();
        for (String[] messageTuple : chatViewModel.getState().getAllMessages())
        {
            // Determine if the message is sent by the current user
            boolean isSentByUser = messageTuple[0].equals(chatViewModel.getState().getCurrentUsername());

            // Create a new MessagePanel with appropriate alignment
            MessagePanel newMessagePanel = new MessagePanel(
                    messageTuple[0], messageTuple[1], messageTuple[2], isSentByUser);
            result.add(newMessagePanel);
        }
        return result;
    }

}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/view/ThreadsView.java =====
package view;

import java.awt.Component;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.GridLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;

import javax.swing.BorderFactory;
import javax.swing.BoxLayout;
import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.JPanel;

import interface_adapter.logout.LogoutController;
import interface_adapter.threads.GetThreadsController;
import interface_adapter.threads.ThreadsState;
import interface_adapter.threads.ThreadsViewModel;
import view.custom_panels.ButtonLabelPanel;
import view.custom_panels.ThreadsPane;

/**
 * The view for when the user is logged in and sees all of their message threads.
 */
public class ThreadsView extends JPanel implements PropertyChangeListener
{

    private final String viewName;
    private final ThreadsViewModel threadsViewModel;

    private final JButton refreshButton;
    private final JButton logoutButton;
    private final JButton addThreadButton;
    private final ThreadsPane threadsList;

    private GetThreadsController getThreadsController;
    private LogoutController logoutController;

    public ThreadsView(ThreadsViewModel threadsViewModel)
    {
        this.threadsViewModel = threadsViewModel;
        this.threadsViewModel.addPropertyChangeListener(this);

        this.viewName = "threads";
        // Initialise the Page Title
        final JLabel titleLabel = new JLabel(ThreadsViewModel.TITLE_LABEL);
        titleLabel.setAlignmentX(Component.CENTER_ALIGNMENT);
        titleLabel.setFont(new Font("Arial", Font.BOLD, ThreadsViewModel.TITLE_FONT_SIZE));

        // Initialize the three buttons
        refreshButton = new JButton(ThreadsViewModel.REFRESH_LABEL);
        logoutButton = new JButton(ThreadsViewModel.LOGOUT_LABEL);
        addThreadButton = new JButton(ThreadsViewModel.ADDTHREAD_LABEL);

        // Initialise the list of threadNames (will be empty at construction)
        final String[] threadNames = threadsViewModel.getState().getThreadNamesList();
        threadsList = new ThreadsPane(threadNames);
        threadsList.setPreferredSize(new Dimension(ThreadsViewModel.THREADSLIST_WIDTH,
                ThreadsViewModel.THREADSLIST_HEIGHT));

        // add action listeners for the buttons
        refreshButton.addActionListener(
                new ActionListener()
                {
                    public void actionPerformed(ActionEvent evt)
                    {
                        if (evt.getSource().equals(refreshButton))
                        {
                            if (getThreadsController != null)
                            {
                                String username = threadsViewModel.getState().getCurrentUsername();
                                getThreadsController.execute(username);
                            }
                            else
                            {
                                System.out.println("Error: GetThreadsController is not set.");
                            }
                        }
                    }
                }
        );
        logoutButton.addActionListener(
                new ActionListener()
                {
                    public void actionPerformed(ActionEvent evt)
                    {
                        if (evt.getSource().equals(logoutButton))
                        {
                            logoutController.execute();
                        }
                    }
                }
        );

        addThreadButton.addActionListener(
                new ActionListener()
                {
                    public void actionPerformed(ActionEvent evt)
                    {
                        if (evt.getSource().equals(addThreadButton))
                        {
                            getThreadsController.switchToAddThreadView();
                        }
                    }
                }
        );

        this.setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
        JPanel topPanel = new JPanel();
        topPanel.setLayout(new GridLayout(ThreadsViewModel.TOP_PANEL_LAYOUT_ROWS,
                ThreadsViewModel.TOP_PANEL_LAYOUT_COLUMNS, 0, 0));
        topPanel.add(refreshButton);
        topPanel.add(logoutButton);
        topPanel.add(addThreadButton);
        this.add(topPanel);
        this.add(titleLabel);
        this.add(threadsList);
        this.setBorder(BorderFactory.createEmptyBorder(ThreadsViewModel.TOP_BORDER_SPACING,
                ThreadsViewModel.BORDER_SPACING, ThreadsViewModel.BORDER_SPACING, ThreadsViewModel.BORDER_SPACING));
    }

    public final String getViewName()
    {
        return viewName;
    }

    public final void setLogoutController(LogoutController logoutController)
    {
        this.logoutController = logoutController;
    }

    public final void setGetThreadsController(GetThreadsController getThreadsController)
    {
        this.getThreadsController = getThreadsController;
    }

    @Override
    public void propertyChange(PropertyChangeEvent evt)
    {
        // Listens for changes in the state and update view accordingly
        final ThreadsState state = (ThreadsState) evt.getNewValue();

        // Set threads list to an updated one (fired when add thread use case or the refresh use case is successful)
        if (evt.getPropertyName().equals("update-thread-list"))
        {
            final String[] updatedThreadNames = state.getThreadNamesList();
            threadsList.updateThreadPanel(updatedThreadNames);

            // Update action listeners for each view button in the threads views
            for (ButtonLabelPanel buttonLabel : threadsList.getButtonLabels())
            {
                buttonLabel.setActionListener(new ActionListener()
                {
                    public void actionPerformed(ActionEvent evt)
                    {
                        String threadName = buttonLabel.getLabelContent();

                        for (Long threadID : threadsViewModel.getState().getThreadHash().keySet())
                        {
                            if (threadsViewModel.getState().getThreadHash().get(threadID).equals(threadName))
                            {
                                getThreadsController.switchToChatView(threadID);
                                System.out.println("Switched to thread: " + threadName);
                            }
                        }
                    }
                });
            }
        }
        else if (evt.getPropertyName().equals("log-out"))
        {
            threadsList.resetPane();
        }
    }
}


===== /Users/mg/IdeaProjects/PingClient-Swing/src/main/java/view/AddThreadView.java =====
package view;


import interface_adapter.add_thread.AddThreadController;
import interface_adapter.add_thread.AddThreadState;
import interface_adapter.add_thread.AddThreadViewModel;
import view.custom_panels.LabelTextPanel;

import javax.swing.*;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;

/**
 * The View for the Add Thread Use Case.
 */
public class AddThreadView extends JPanel implements ActionListener, PropertyChangeListener
{
    private final String viewName = "add thread";

    private final AddThreadViewModel addThreadViewModel;
    private final JTextField threadNameInputField = new JTextField(15);
    private final JTextField usernameListInputField = new JTextField(15);
    private final JButton addThread;
    private final JButton toThreads;
    private AddThreadController addThreadController;

    public AddThreadView(AddThreadViewModel addThreadViewModel)
    {
        this.addThreadViewModel = addThreadViewModel;
        this.addThreadViewModel.addPropertyChangeListener(this);

        // Initialize the Page Title
        final JLabel title = new JLabel(AddThreadViewModel.TITLE_LABEL);
        title.setAlignmentX(Component.CENTER_ALIGNMENT);

        // Initialize text entries
        final LabelTextPanel threadNameInfo = new LabelTextPanel(
                new JLabel(AddThreadViewModel.THREAD_NAME_LABEL), threadNameInputField);
        final LabelTextPanel usersListInfo = new LabelTextPanel(
                new JLabel(AddThreadViewModel.USERS_LIST_LABEL), usernameListInputField);

        // Initialize Buttons
        final JPanel buttons = new JPanel();
        toThreads = new JButton(AddThreadViewModel.TO_THREADS_BUTTON_LABEL);
        buttons.add(toThreads);
        addThread = new JButton(AddThreadViewModel.ADD_THREAD_BUTTON_LABEL);
        buttons.add(addThread);

        // Add Action listener for the toThreads button
        toThreads.addActionListener(
                new ActionListener()
                {
                    public void actionPerformed(ActionEvent evt)
                    {
                        addThreadController.switchToThreadsView();
                    }
                }
        );

        // Add Action listener for the addThread button.
        addThread.addActionListener(
                new ActionListener()
                {
                    public void actionPerformed(ActionEvent evt)
                    {
                        final AddThreadState currentState = addThreadViewModel.getState();
                        addThreadController.execute(
                                currentState.getThreadName(),
                                currentState.getUsernameList(),
                                currentState.getCurrentUsername());
                    }
                }
        );

        // Add listeners for the text entries
        threadNameListener();
        usersListListener();

        // Set Up the layout for the UI
        this.setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));

        this.add(title);
        this.add(threadNameInfo);
        this.add(usersListInfo);
        this.add(buttons);

        // Add margin of BORDER_DIMENSIONS pixels on all sides
        this.setBorder(BorderFactory.createEmptyBorder(
                AddThreadViewModel.BORDER_DIMENSIONS,
                AddThreadViewModel.BORDER_DIMENSIONS,
                AddThreadViewModel.BORDER_DIMENSIONS,
                AddThreadViewModel.BORDER_DIMENSIONS
        ));
    }

    /**
     * Listens to the changes in the thread name field and updates the current state.
     */
    private void threadNameListener()
    {
        threadNameInputField.getDocument().addDocumentListener(new DocumentListener()
        {

            private void documentListenerHelper()
            {
                final AddThreadState currentState = addThreadViewModel.getState();
                currentState.setThreadName(threadNameInputField.getText());
                addThreadViewModel.setState(currentState);
            }

            @Override
            public void insertUpdate(DocumentEvent e)
            {
                // Change if a new value is added
                documentListenerHelper();
            }

            @Override
            public void removeUpdate(DocumentEvent e)
            {
                // Change if a value is removed
                documentListenerHelper();
            }

            @Override
            public void changedUpdate(DocumentEvent e)
            {
                // Change if a value is changed
                documentListenerHelper();
            }
        });
    }

    /**
     * Listens to the changes in the users list field and updates the current state.
     */
    private void usersListListener()
    {
        usernameListInputField.getDocument().addDocumentListener(new DocumentListener()
        {

            private void documentListenerHelper()
            {
                final AddThreadState currentState = addThreadViewModel.getState();
                currentState.setUsernameList(usernameListInputField.getText());
                addThreadViewModel.setState(currentState);
            }

            @Override
            public void insertUpdate(DocumentEvent e)
            {
                // Change if a new value is added
                documentListenerHelper();
            }

            @Override
            public void removeUpdate(DocumentEvent e)
            {
                // Change if a value is removed
                documentListenerHelper();
            }

            @Override
            public void changedUpdate(DocumentEvent e)
            {
                // Change if a value is changed
                documentListenerHelper();
            }
        });
    }

    @Override
    public void actionPerformed(ActionEvent evt)
    {
        System.out.println("Click " + evt.getActionCommand());
    }

    @Override
    public void propertyChange(PropertyChangeEvent evt)
    {
        // check for errors
        final AddThreadState state = (AddThreadState) evt.getNewValue();
        if (state.getAddThreadError() != null)
        {
            JOptionPane.showMessageDialog(this, state.getAddThreadError());
        }
        if (evt.getPropertyName().equals("reset-success"))
        {
            JOptionPane.showMessageDialog(this, state.getAddThreadSuccess());
            threadNameInputField.setText(state.getThreadName());
            usernameListInputField.setText(state.getUsernameList());
        }
    }

    public final String getViewName()
    {
        return viewName;
    }

    public final void setAddThreadController(AddThreadController controller)
    {
        this.addThreadController = controller;
    }
}


